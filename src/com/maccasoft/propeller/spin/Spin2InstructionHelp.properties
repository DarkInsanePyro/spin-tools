CON=<b>CON</b><br/><br/>Constant declarations (CON is the initial/default block type)
OBJ=<b>OBJ</b><br/><br/>Child-object instantiations
VAR=<b>VAR</b><br/><br/>Variable declarations
PUB=<b>PUB</b><br/><br/>Public method for use by the parent object and within this object
PRI=<b>PRI</b><br/><br/>Private method for use within this object
DAT=<b>DAT</b><br/><br/>Data declarations, including PASM code

hubset=<b>HUBSET(Value)</b><br/><br/>Execute HUBSET instruction using Value
clkset=<b>CLKSET(NewCLKMODE, NewCLKFREQ)</b><br/><br/>Safely establish new clock settings, updates CLKMODE and CLKFREQ
cogspin=<b>COGSPIN(CogNum, Method({Pars}), StkAddr)</b><br/><br/>Start Spin2 method in a cog, returns cog's ID if used as an expression element, -1 = no cog free
coginit=<b>COGINIT(CogNum, PASMaddr, PTRAvalue)</b><br/><br/>Start PASM code in a cog, returns cog's ID if used as an expression element, -1 = no cog free
cogstop=<b>COGSTOP(CogNum)</b><br/><br/>Stop cog CogNum
cogid=<b>COGID() : CogNum</b><br/><br/>Get this cog's ID
cogchk=<b>COGCHK(CogNum) : Running</b><br/><br/>Check if cog CogNum is running, returns -1 if running or 0 if not
locknew=<b>LOCKNEW() : LockNum</b><br/><br/>Check out a new LOCK from inventory, LockNum = 0..15 if successful or &lt; 0 if no LOCK available
lockret=<b>LOCKRET(LockNum)</b><br/><br/>Return a certain LOCK to inventory
locktry=<b>LOCKTRY(LockNum) : LockState</b><br/><br/>Try to capture a certain LOCK, LockState = -1 if successful or 0 if another cog has captured the LOCK
lockrel=<b>LOCKREL(LockNum)</b><br/><br/>Release a certain LOCK
lockchk=<b>LOCKCHK(LockNum) : LockState</b><br/><br/>Check a certain LOCK's state, LockState[31] = captured, LockState[3:0] = current or last owner cog
cogatn=<b>COGATN(CogMask)</b><br/><br/>Strobe ATN input(s) of cog(s) according to 16-bit CogMask
pollatn=<b>POLLATN() : AtnFlag</b><br/><br/>Check if this cog has received an ATN strobe, AtnFlag = -1 if ATN strobed or 0 if not strobed
waitatn=<b>WAITATN()</b><br/><br/>Wait for this cog to receive an ATN strobe

pinw=<b>PINW | PINWRITE(PinField, Data)</b><br/><br/>Drive PinField pin(s) with Data
pinl=<b>PINL | PINLOW(PinField)</b><br/><br/>Drive PinField pin(s) low
pinh=<b>PINH | PINHIGH(PinField)</b><br/><br/>Drive PinField pin(s) high
pint=<b>PINT | PINTOGGLE(PinField)</b><br/><br/>Drive and toggle PinField pin(s)
pinf=<b>PINF | PINFLOAT(PinField)</b><br/><br/>Float PinField pin(s)
pinr=<b>PINR | PINREAD(PinField) : PinStates</b><br/><br/>Read PinField pin(s)
pinstart=<b>PINSTART(PinField, Mode, Xval, Yval)</b><br/><br/>Start PinField smart pin(s): DIR=0, then WRPIN=Mode, WXPIN=Xval, WYPIN=Yval, then DIR=1
pinclear=<b>PINCLEAR(PinField)</b><br/><br/>Clear PinField smart pin(s): DIR=0, then WRPIN=0
wrpin=<b>WRPIN(PinField, Data)</b><br/><br/>Write 'mode' register(s) of PinField smart pin(s) with Data
wxpin=<b>WXPIN(PinField, Data)</b><br/><br/>Write 'X' register(s) of PinField smart pin(s) with Data
wypin=<b>WYPIN(PinField, Data)</b><br/><br/>Write 'Y' register(s) of PinField smart pin(s) with Data
akpin=<b>AKPIN(PinField)</b><br/><br/>Acknowledge PinField smart pin(s)
rdpin=<b>RDPIN(Pin) : Zval</b><br/><br/>Read Pin smart pin and acknowledge, Zval[31] = C flag from RDPIN, other bits are RDPIN data
rqpin=<b>RQPIN(Pin) : Zval</b><br/><br/>Read Pin smart pin without acknowledge, Zval[31] = C flag from RQPIN, other bits are RQPIN data

pinwrite=${PINW}
pinlow=${PINL}
pinhigh=${PINH}
pintoggle=${PINT}
pinfloat=${PINF}
pinread=${PINR}

getct=<b>GETCT() : Count</b><br/><br/>Get 32-bit system counter
pollct=<b>POLLCT(Tick) : Past</b><br/><br/>Check if system counter has gone past 'Tick', returns -1 if past or 0 if not past
waitct=<b>WAITCT(Tick)</b><br/><br/>Wait for system counter to get past 'Tick'
waitus=<b>WAITUS(Microseconds)</b><br/><br/>Wait Microseconds, uses CLKFREQ
waitms=<b>WAITMS(Milliseconds)</b><br/><br/>Wait Milliseconds, uses CLKFREQ
getsec=<b>GETSEC() : Seconds</b><br/><br/>Get seconds since booting, uses 64-bit system counter and CLKFREQ, rolls over every 136 years.
getms=<b>GETMS() : Milliseconds</b><br/><br/>Get milliseconds since booting, uses 64-bit system counter and CLKFREQ, rolls over every 49.7 days.

call=<b>CALL(RegOrHubAddr)</b><br/><br/>CALL PASM code at Addr, PASM code should avoid registers $130..$1D7 and LUT
regexec=<b>REGEXEC(HubAddr)</b><br/><br/>Load a self-defined chunk of PASM code at HubAddr into registers and CALL it. See REGEXEC description.
regload=<b>REGLOAD(HubAddr)</b><br/><br/>Load a self-defined chunk of PASM code or data at HubAddr into registers. See REGLOAD description.

rotxy=<b>ROTXY(x, y, angle32bit) : rotx, roty</b><br/><br/>Rotate (x,y) by angle32bit and return rotated (x,y)
polxy=<b>POLXY(length, angle32bit) : x, y</b><br/><br/>Convert (length,angle32bit) to (x,y)
xypol=<b>XYPOL(x, y) : length, angle32bit</b><br/><br/>Convert (x,y) to (length,angle32bit)
qsin=<b>QSIN(length, angle, twopi) : y</b><br/><br/>Rotate (length,0) by (angle / twopi) * 2Pi and return y. Use 0 for twopi = $1_0000_0000. Twopi is unsigned.
qcos=<b>QCOS(length, angle, twopi) : x</b><br/><br/>Rotate (length,0) by (angle / twopi) * 2Pi and return x. Use 0 for twopi = $1_0000_0000. Twopi is unsigned.
muldiv64=<b>MULDIV64(mult1, mult2, divisor) : quotient</b><br/><br/>Divide the 64-bit product of 'mult1' and 'mult2' by 'divisor', return quotient (unsigned operation)
getrnd=<b>GETRND() : Rnd</b><br/><br/>Get random long (from xoroshiro128** PRNG, seeded on boot with thermal noise from ADC)

getregs=<b>GETREGS(HubAddr, CogAddr, Count)</b><br/><br/>Move Count registers at CogAddr to longs at HubAddr
setregs=<b>SETREGS(HubAddr, CogAddr, Count)</b><br/><br/>Move Count longs at HubAddr to registers at CogAddr
bytemove=<b>BYTEMOVE(Dest, Source, Count)</b><br/><br/>Move Count bytes from Source to Dest
wordmove=<b>WORDMOVE(Dest, Source, Count)</b><br/><br/>Move Count words from Source to Dest
longmove=<b>LONGMOVE(Dest, Source, Count)</b><br/><br/>Move Count longs from Source to Dest
bytefill=<b>BYTEFILL(Dest, Value, Count)</b><br/><br/>Fill Count bytes at Dest with Value
wordfill=<b>WORDFILL(Dest, Value, Count)</b><br/><br/>Fill Count words at Dest with Value
longfill=<b>LONGFILL(Dest, Value, Count)</b><br/><br/>Fill Count longs at Dest with Value

strsize=<b>STRSIZE(Addr) : Size</b><br/><br/>Count bytes in zero-terminated string at Addr, return string size, not including zero terminator
strcomp=<b>STRCOMP(AddrA, AddrB) : Match</b><br/><br/>Compare zero-terminated strings at AddrA and AddrB, return -1 if match or 0 if mismatch
string=<b>STRING("Text",9) : StringAddress</b><br/><br/>Compose a zero-terminated string (quoted characters and values 1..255 allowed), return address of string

lookup=<b>LOOKUP(Index: v1, v2..v3, etc) : Value</b><br/><br/>Lookup value (values and ranges allowed) using 1-based index, return value (0 if index out of range)
lookupz=<b>LOOKUPZ(Index: v1, v2..v3, etc) : Value</b><br/><br/>Lookup value (values and ranges allowed) using 0-based index, return value (0 if index out of range)
lookdown=<b>LOOKDOWN(Value: v1, v2..v3, etc) : Index</b><br/><br/>Determine 1-based index of matching value (values and ranges allowed), return index (0 if no match)
lookdownz=<b>LOOKDOWNZ(Value: v1, v2..v3, etc) : Index</b><br/><br/>Determine 0-based index of matching value (values and ranges allowed), return index (0 if no match)

addpins=<b>x ADDPINS y</b><p>Make pinfield, (x & $3F) | (y & $1F) << 6</p>

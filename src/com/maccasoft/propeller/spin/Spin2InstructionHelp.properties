CON=<b>CON</b><br/><br/>Constant declarations (CON is the initial/default block type)
OBJ=<b>OBJ</b><br/><br/>Child-object instantiations
VAR=<b>VAR</b><br/><br/>Variable declarations
PUB=<b>PUB</b><br/><br/>Public method for use by the parent object and within this object
PRI=<b>PRI</b><br/><br/>Private method for use within this object
DAT=<b>DAT</b><br/><br/>Data declarations, including PASM code

HUBSET=<b>HUBSET(Value)</b><br/><br/>Execute HUBSET instruction using Value
CLKSET=<b>CLKSET(NewCLKMODE, NewCLKFREQ)</b><br/><br/>Safely establish new clock settings, updates CLKMODE and CLKFREQ
COGSPIN=<b>COGSPIN(CogNum, Method({Pars}), StkAddr)</b><br/><br/>Start Spin2 method in a cog, returns cog's ID if used as an expression element, -1 = no cog free
COGINIT=<b>COGINIT(CogNum, PASMaddr, PTRAvalue)</b><br/><br/>Start PASM code in a cog, returns cog's ID if used as an expression element, -1 = no cog free
COGSTOP=<b>COGSTOP(CogNum)</b><br/><br/>Stop cog CogNum
COGID=<b>COGID() : CogNum</b><br/><br/>Get this cog's ID
COGCHK=<b>COGCHK(CogNum) : Running</b><br/><br/>Check if cog CogNum is running, returns -1 if running or 0 if not
LOCKNEW=<b>LOCKNEW() : LockNum</b><br/><br/>Check out a new LOCK from inventory, LockNum = 0..15 if successful or &lt; 0 if no LOCK available
LOCKRET=<b>LOCKRET(LockNum)</b><br/><br/>Return a certain LOCK to inventory
LOCKTRY=<b>LOCKTRY(LockNum) : LockState</b><br/><br/>Try to capture a certain LOCK, LockState = -1 if successful or 0 if another cog has captured the LOCK
LOCKREL=<b>LOCKREL(LockNum)</b><br/><br/>Release a certain LOCK
LOCKCHK=<b>LOCKCHK(LockNum) : LockState</b><br/><br/>Check a certain LOCK's state, LockState[31] = captured, LockState[3:0] = current or last owner cog
COGATN=<b>COGATN(CogMask)</b><br/><br/>Strobe ATN input(s) of cog(s) according to 16-bit CogMask
POLLATN=<b>POLLATN() : AtnFlag</b><br/><br/>Check if this cog has received an ATN strobe, AtnFlag = -1 if ATN strobed or 0 if not strobed
WAITATN=<b>WAITATN()</b><br/><br/>Wait for this cog to receive an ATN strobe

PINW=<b>PINW | PINWRITE(PinField, Data)</b><br/><br/>Drive PinField pin(s) with Data
PINL=<b>PINL | PINLOW(PinField)</b><br/><br/>Drive PinField pin(s) low
PINH=<b>PINH | PINHIGH(PinField)</b><br/><br/>Drive PinField pin(s) high
PINH=<b>PINH | PINTOGGLE(PinField)</b><br/><br/>Drive and toggle PinField pin(s)
PINF=<b>PINF | PINFLOAT(PinField)</b><br/><br/>Float PinField pin(s)
PINR=<b>PINR | PINREAD(PinField) : PinStates</b><br/><br/>Read PinField pin(s)
PINSTART=<b>PINSTART(PinField, Mode, Xval, Yval)</b><br/><br/>Start PinField smart pin(s): DIR=0, then WRPIN=Mode, WXPIN=Xval, WYPIN=Yval, then DIR=1
PINCLEAR=<b>PINCLEAR(PinField)</b><br/><br/>Clear PinField smart pin(s): DIR=0, then WRPIN=0
WRPIN=<b>WRPIN(PinField, Data)</b><br/><br/>Write 'mode' register(s) of PinField smart pin(s) with Data
WXPIN=<b>WXPIN(PinField, Data)</b><br/><br/>Write 'X' register(s) of PinField smart pin(s) with Data
WYPIN=<b>WYPIN(PinField, Data)</b><br/><br/>Write 'Y' register(s) of PinField smart pin(s) with Data
AKPIN=<b>AKPIN(PinField)</b><br/><br/>Acknowledge PinField smart pin(s)
RDPIN=<b>RDPIN(Pin) : Zval</b><br/><br/>Read Pin smart pin and acknowledge, Zval[31] = C flag from RDPIN, other bits are RDPIN data
RQPIN=<b>RQPIN(Pin) : Zval</b><br/><br/>Read Pin smart pin without acknowledge, Zval[31] = C flag from RQPIN, other bits are RQPIN data

PINWRITE=${PINW}
PINLOW=${PINL}
PINHIGH=${PINH}
PINTOGGLE=${PINT}
PINFLOAT=${PINF}
PINREAD=${PINR}

GETCT=<b>GETCT() : Count</b><br/><br/>Get 32-bit system counter
POLLCT=<b>POLLCT(Tick) : Past</b><br/><br/>Check if system counter has gone past 'Tick', returns -1 if past or 0 if not past
WAITCT=<b>WAITCT(Tick)</b><br/><br/>Wait for system counter to get past 'Tick'
WAITUS=<b>WAITUS(Microseconds)</b><br/><br/>Wait Microseconds, uses CLKFREQ
WAITMS=<b>WAITMS(Milliseconds)</b><br/><br/>Wait Milliseconds, uses CLKFREQ
GETSEC=<b>GETSEC() : Seconds</b><br/><br/>Get seconds since booting, uses 64-bit system counter and CLKFREQ, rolls over every 136 years.
GETMS=<b>GETMS() : Milliseconds</b><br/><br/>Get milliseconds since booting, uses 64-bit system counter and CLKFREQ, rolls over every 49.7 days.

CALL=<b>CALL(RegOrHubAddr)</b><br/><br/>CALL PASM code at Addr, PASM code should avoid registers $130..$1D7 and LUT
REGEXEC=<b>REGEXEC(HubAddr)</b><br/><br/>Load a self-defined chunk of PASM code at HubAddr into registers and CALL it. See REGEXEC description.
REGLOAD=<b>REGLOAD(HubAddr)</b><br/><br/>Load a self-defined chunk of PASM code or data at HubAddr into registers. See REGLOAD description.

ROTXY=<b>ROTXY(x, y, angle32bit) : rotx, roty</b><br/><br/>Rotate (x,y) by angle32bit and return rotated (x,y)
POLXY=<b>POLXY(length, angle32bit) : x, y</b><br/><br/>Convert (length,angle32bit) to (x,y)
XYPOL=<b>XYPOL(x, y) : length, angle32bit</b><br/><br/>Convert (x,y) to (length,angle32bit)
QSIN=<b>QSIN(length, angle, twopi) : y</b><br/><br/>Rotate (length,0) by (angle / twopi) * 2Pi and return y. Use 0 for twopi = $1_0000_0000. Twopi is unsigned.
QCOS=<b>QCOS(length, angle, twopi) : x</b><br/><br/>Rotate (length,0) by (angle / twopi) * 2Pi and return x. Use 0 for twopi = $1_0000_0000. Twopi is unsigned.
MULDIV64=<b>MULDIV64(mult1, mult2, divisor) : quotient</b><br/><br/>Divide the 64-bit product of 'mult1' and 'mult2' by 'divisor', return quotient (unsigned operation)
GETRND=<b>GETRND() : Rnd</b><br/><br/>Get random long (from xoroshiro128** PRNG, seeded on boot with thermal noise from ADC)

GETREGS=<b>GETREGS(HubAddr, CogAddr, Count)</b><br/><br/>Move Count registers at CogAddr to longs at HubAddr
SETREGS=<b>SETREGS(HubAddr, CogAddr, Count)</b><br/><br/>Move Count longs at HubAddr to registers at CogAddr
BYTEMOVE=<b>BYTEMOVE(Dest, Source, Count)</b><br/><br/>Move Count bytes from Source to Dest
WORDMOVE=<b>WORDMOVE(Dest, Source, Count)</b><br/><br/>Move Count words from Source to Dest
LONGMOVE=<b>LONGMOVE(Dest, Source, Count)</b><br/><br/>Move Count longs from Source to Dest
BYTEFILL=<b>BYTEFILL(Dest, Value, Count)</b><br/><br/>Fill Count bytes at Dest with Value
WORDFILL=<b>WORDFILL(Dest, Value, Count)</b><br/><br/>Fill Count words at Dest with Value
LONGFILL=<b>LONGFILL(Dest, Value, Count)</b><br/><br/>Fill Count longs at Dest with Value

STRSIZE=<b>STRSIZE(Addr) : Size</b><br/><br/>Count bytes in zero-terminated string at Addr, return string size, not including zero terminator
STRCOMP=<b>STRCOMP(AddrA, AddrB) : Match</b><br/><br/>Compare zero-terminated strings at AddrA and AddrB, return -1 if match or 0 if mismatch
STRING=<b>STRING("Text",9) : StringAddress</b><br/><br/>Compose a zero-terminated string (quoted characters and values 1..255 allowed), return address of string

LOOKUP=<b>LOOKUP(Index: v1, v2..v3, etc) : Value</b><br/><br/>Lookup value (values and ranges allowed) using 1-based index, return value (0 if index out of range)
LOOKUPZ=<b>LOOKUPZ(Index: v1, v2..v3, etc) : Value</b><br/><br/>Lookup value (values and ranges allowed) using 0-based index, return value (0 if index out of range)
LOOKDOWN=<b>LOOKDOWN(Value: v1, v2..v3, etc) : Index</b><br/><br/>Determine 1-based index of matching value (values and ranges allowed), return index (0 if no match)
LOOKDOWNZ=<b>LOOKDOWNZ(Value: v1, v2..v3, etc) : Index</b><br/><br/>Determine 0-based index of matching value (values and ranges allowed), return index (0 if no match)

ADDPINS=<b>x ADDPINS y</b><p>Make pinfield, (x & $3F) | (y & $1F) << 6</p>

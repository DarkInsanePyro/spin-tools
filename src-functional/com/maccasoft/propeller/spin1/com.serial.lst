0000     00B71B00      Frequency 12000000 Hz
0004     00            RCFast
0005     1B            Check Sum
0006     0010          Base of Program
0008     0218          Base of Variables
000A     02C8          Base of Stack
000C     0184          Initial Program Counter
000E     02D0          Initial Stack Pointer
                       File "com.serial.spin"
0010     0208 0009     Link to Next Object
0014     0174 0000     Link to PUB Start(baudrate) : okay
0018     017F 0000     Link to PUB StartRxTx(rxpin, txpin, mode, baudrate) : okay
001C     01A1 0000     Link to PUB Stop
0020     01AF 0000     Link to PUB Count
0024     01BE 0000     Link to PUB Flush
0028     01C8 0000     Link to PUB Char(ch)
002C     01E9 0000     Link to PUB CharIn
0030     01F5 0000     Link to PRI RxCheck
0034 000               DAT
0034 000                                       org
0034 000 A0BCA9F0      entry                   mov     t1,par                'get structure address
0038 001 80FCA810                              add     t1,#4 << 2            'skip past heads and tails
003C 002 08BCAA54                              rdlong  t2,t1                 'get rx_pin
0040 003 A0FCB201                              mov     rxmask,#1
0044 004 2CBCB255                              shl     rxmask,t2
0048 005 80FCA804                              add     t1,#4                 'get tx_pin
004C 006 08BCAA54                              rdlong  t2,t1
0050 007 A0FCBE01                              mov     txmask,#1
0054 008 2CBCBE55                              shl     txmask,t2
0058 009 80FCA804                              add     t1,#4                 'get rxtx_mode
005C 00A 08BCAE54                              rdlong  rxtxmode,t1
0060 00B 80FCA804                              add     t1,#4                 'get bit_ticks
0064 00C 08BCB054                              rdlong  bitticks,t1
0068 00D 80FCA804                              add     t1,#4                 'get buffer_ptr
006C 00E 08BCB454                              rdlong  rxbuff,t1
0070 00F A0BCC05A                              mov     txbuff,rxbuff
0074 010 80FCC040                              add     txbuff,#BUFFER_LENGTH
0078 011 627CAE04                              test    rxtxmode,#%100  wz    'init tx pin according to mode
007C 012 617CAE02                              test    rxtxmode,#%010  wc
0080 013 689BE85F              if_z_ne_c       or      outa,txmask
0084 014 68ABEC5F              if_z            or      dira,txmask
0088 015 A0FCC833                              mov     txcode,#transmit      'initialize ping-pong multitasking
008C 016 5CBCBC64      receive                 jmpret  rxcode,txcode         'run chunk of tx code, then return
0090 017 627CAE01                              test    rxtxmode,#%001  wz    'wait for start bit on rx pin
0094 018 613CB3F2                              test    rxmask,ina      wc
0098 019 5C640016              if_z_eq_c       jmp     #receive
009C 01A A0FCB809                              mov     rxbits,#9             'ready to receive byte
00A0 01B A0BCBA58                              mov     rxcnt,bitticks
00A4 01C 28FCBA01                              shr     rxcnt,#1
00A8 01D 80BCBBF1                              add     rxcnt,cnt
00AC 01E 80BCBA58      :bit                    add     rxcnt,bitticks        'ready next bit period
00B0 01F 5CBCBC64      :wait                   jmpret  rxcode,txcode         'run chunk of tx code, then return
00B4 020 A0BCA85D                              mov     t1,rxcnt              'check if bit receive period done
00B8 021 84BCA9F1                              sub     t1,cnt
00BC 022 C17CA800                              cmps    t1,#0           wc
00C0 023 5C4C001F              if_nc           jmp     #:wait
00C4 024 613CB3F2                              test    rxmask,ina      wc    'receive bit on rx pin
00C8 025 30FCB601                              rcr     rxdata,#1
00CC 026 E4FCB81E                              djnz    rxbits,#:bit
00D0 027 28FCB617                              shr     rxdata,#32-9          'justify and trim received byte
00D4 028 60FCB6FF                              and     rxdata,#$FF
00D8 029 627CAE01                              test    rxtxmode,#%001  wz    'if rx inverted, invert byte
00DC 02A 6CD4B6FF              if_nz           xor     rxdata,#$FF
00E0 02B 08BCABF0                              rdlong  t2,par                'save received byte and inc head
00E4 02C 80BCAA5A                              add     t2,rxbuff
00E8 02D 003CB655                              wrbyte  rxdata,t2
00EC 02E 84BCAA5A                              sub     t2,rxbuff
00F0 02F 80FCAA01                              add     t2,#1
00F4 030 60FCAA3F                              and     t2,#BUFFER_MASK
00F8 031 083CABF0                              wrlong  t2,par
00FC 032 5C7C0016                              jmp     #receive              'byte done, receive next byte
0100 033 5CBCC85E      transmit                jmpret  txcode,rxcode         'run chunk of rx code, then return
0104 034 A0BCA9F0                              mov     t1,par                'check for head <> tail
0108 035 80FCA808                              add     t1,#2 << 2
010C 036 08BCAA54                              rdlong  t2,t1
0110 037 80FCA804                              add     t1,#1 << 2
0114 038 08BCAC54                              rdlong  t3,t1
0118 039 863CAA56                              cmp     t2,t3           wz
011C 03A 5C680033              if_z            jmp     #transmit
0120 03B 80BCAC60                              add     t3,txbuff             'get byte and inc tail
0124 03C 00BCC256                              rdbyte  txdata,t3
0128 03D 84BCAC60                              sub     t3,txbuff
012C 03E 80FCAC01                              add     t3,#1
0130 03F 60FCAC3F                              and     t3,#BUFFER_MASK
0134 040 083CAC54                              wrlong  t3,t1
0138 041 68FCC300                              or      txdata,#$100          'ready byte to transmit
013C 042 2CFCC202                              shl     txdata,#2
0140 043 68FCC201                              or      txdata,#1
0144 044 A0FCC40B                              mov     txbits,#11
0148 045 A0BCC7F1                              mov     txcnt,cnt
014C 046 627CAE04      :bit                    test    rxtxmode,#%100  wz    'output bit on tx pin
0150 047 617CAE02                              test    rxtxmode,#%010  wc    'according to mode
0154 048 6CE0C201              if_z_and_c      xor     txdata,#1
0158 049 29FCC201                              shr     txdata,#1       wc
015C 04A 70ABE85F              if_z            muxc    outa,txmask
0160 04B 7497EC5F              if_nz           muxnc   dira,txmask
0164 04C 80BCC658                              add     txcnt,bitticks        'ready next cnt
0168 04D 5CBCC85E      :wait                   jmpret  txcode,rxcode         'run chunk of rx code, then return
016C 04E A0BCA863                              mov     t1,txcnt              'check if bit transmit period done
0170 04F 84BCA9F1                              sub     t1,cnt
0174 050 C17CA800                              cmps    t1,#0           wc
0178 051 5C4C004D              if_nc           jmp     #:wait
017C 052 E4FCC446                              djnz    txbits,#:bit          'another bit to transmit?
0180 053 5C7C0033                              jmp     #transmit             'byte done, transmit next byte
0184 054               t1                      res     1
0184 055               t2                      res     1
0184 056               t3                      res     1
0184 057               rxtxmode                res     1
0184 058               bitticks                res     1
0184 059               rxmask                  res     1
0184 05A               rxbuff                  res     1
0184 05B               rxdata                  res     1
0184 05C               rxbits                  res     1
0184 05D               rxcnt                   res     1
0184 05E               rxcode                  res     1
0184 05F               txmask                  res     1
0184 060               txbuff                  res     1
0184 061               txdata                  res     1
0184 062               txbits                  res     1
0184 063               txcnt                   res     1
0184 064               txcode                  res     1
0184                   PUB Start(baudrate) : okay
0184                       okay := StartRxTx(31, 30, 0, baudrate)
0184     00            ; Frame_Call_Return
0185     37 24         ; Push_Packed_Lit, $0000001F
0187     38 1E         ; Push_Byte_Lit, $1E
0189     35            ; Push_0
018A     64            ; Push_LocalMem_Long_1
018B     05 02         ; Call, $02
018D     61            ; Pop_LocalMem_Long_0
018E     32            ; Return
018F                   PUB StartRxTx(rxpin, txpin, mode, baudrate) : okay
018F                       Stop
018F     01            ; Frame_Call_Noreturn
0190     05 03         ; Call, $03
0192                       longfill(@rx_head, 0, 4)
0192     47            ; Reference_VariableMem_Long_1
0193     35            ; Push_0
0194     37 01         ; Push_Packed_Lit, $00000004
0196     1A            ; Longfill
0197                       longmove(@rx_pin, @rxpin, 3)
0197     57            ; Reference_VariableMem_Long_5
0198     67            ; Reference_LocalMem_Long_1
0199     37 21         ; Push_Packed_Lit, $00000003
019B     1E            ; Longmove
019C                       bit_ticks := clkfreq / baudrate
019C     35            ; Push_0
019D     C0            ; Push_MainMem_Long
019E     70            ; Push_LocalMem_Long_4
019F     F6            ; Divide
01A0     C9 20         ; Pop_VariableMem_Long, $0020
01A2                       buffer_ptr := @rx_buffer
01A2     8B 28         ; Reference_VariableMem_Byte, $0028
01A4     C9 24         ; Pop_VariableMem_Long, $0024
01A6                       okay := cog := cognew(@entry, @rx_head) + 1
01A6     34            ; Push_Neg1
01A7     C7 24         ; Reference_ObjectMem_Long, $0024
01A9     47            ; Reference_VariableMem_Long_1
01AA     28            ; Coginit_Returns
01AB     36            ; Push_1
01AC     EC            ; Add
01AD     42 80         ; Effect_VariableMem_Long_0, write, push
01AF     61            ; Pop_LocalMem_Long_0
01B0     32            ; Return
01B1                   PUB Stop
01B1                       if cog
01B1     40            ; Push_VariableMem_Long_0
01B2     0A 05         ; Jump_If_False, $0005
01B4                           cogstop(cog~ - 1)
01B4     42 98         ; Effect_VariableMem_Long_0, post-clear, push
01B6     36            ; Push_1
01B7     ED            ; Subtract
01B8     21            ; Cogstop
01B9                       longfill(@rx_head, 0, 9)
01B9     47            ; Reference_VariableMem_Long_1
01BA     35            ; Push_0
01BB     38 09         ; Push_Byte_Lit, $09
01BD     1A            ; Longfill
01BE     32            ; Return
01BF                   PUB Count
01BF                       result := rx_head - rx_tail
01BF     44            ; Push_VariableMem_Long_1
01C0     48            ; Push_VariableMem_Long_2
01C1     ED            ; Subtract
01C2     61            ; Pop_LocalMem_Long_0
01C3                       result -= BUFFER_LENGTH*(Count < 0)
01C3     37 05         ; Push_Packed_Lit, $00000040
01C5     00            ; Frame_Call_Return
01C6     05 04         ; Call, $04
01C8     35            ; Push_0
01C9     F9            ; Less
01CA     F4            ; Multiply
01CB     62 4D         ; Effect_LocalMem_Long_0, Subtract, swap
01CD     32            ; Return
01CE                   PUB Flush
01CE                       repeat while RxCheck => 0
01CE     00            ; Frame_Call_Return
01CF     05 08         ; Call, $08
01D1     35            ; Push_0
01D2     FE            ; Greater_Equal
01D3     0A 02         ; Jump_If_False, $0002
01D5     04 77         ; Branch, $FFF7
01D7     32            ; Return
01D8                   PUB Char(ch)
01D8                       repeat until (tx_tail <> ((tx_head + 1) & BUFFER_MASK))
01D8     50            ; Push_VariableMem_Long_4
01D9     4C            ; Push_VariableMem_Long_3
01DA     36            ; Push_1
01DB     EC            ; Add
01DC     37 25         ; Push_Packed_Lit, $0000003F
01DE     E8            ; Bit_And
01DF     FB            ; Not_Equal
01E0     0B 02         ; Jump_If_True, $0002
01E2     04 74         ; Branch, $FFF4
01E4                       tx_buffer[tx_head] := ch
01E4     64            ; Push_LocalMem_Long_1
01E5     4C            ; Push_VariableMem_Long_3
01E6     99 68         ; Pop_Indexed_VariableMem_Byte, $0068
01E8                       tx_head := (tx_head + 1) & BUFFER_MASK
01E8     4C            ; Push_VariableMem_Long_3
01E9     36            ; Push_1
01EA     EC            ; Add
01EB     37 25         ; Push_Packed_Lit, $0000003F
01ED     E8            ; Bit_And
01EE     4D            ; Pop_VariableMem_Long_3
01EF                       if rxtx_mode & %1000
01EF     5C            ; Push_VariableMem_Long_7
01F0     37 02         ; Push_Packed_Lit, $00000008
01F2     E8            ; Bit_And
01F3     0A 03         ; Jump_If_False, $0003
01F5                           CharIn
01F5     01            ; Frame_Call_Noreturn
01F6     05 07         ; Call, $07
01F8     32            ; Return
01F9                   PUB CharIn
01F9                       repeat while (result := RxCheck) < 0
01F9     00            ; Frame_Call_Return
01FA     05 08         ; Call, $08
01FC     62 80         ; Effect_LocalMem_Long_0, write, push
01FE     35            ; Push_0
01FF     F9            ; Less
0200     0A 02         ; Jump_If_False, $0002
0202     04 75         ; Branch, $FFF5
0204     32            ; Return
0205                   PRI RxCheck
0205                       result~~
0205     62 1C         ; Effect_LocalMem_Long_0, post-set
0207                       if rx_tail <> rx_head
0207     48            ; Push_VariableMem_Long_2
0208     44            ; Push_VariableMem_Long_1
0209     FB            ; Not_Equal
020A     0A 0B         ; Jump_If_False, $000B
020C                           result := rx_buffer[rx_tail]
020C     48            ; Push_VariableMem_Long_2
020D     98 28         ; Push_Indexed_VariableMem_Byte, $0028
020F     61            ; Pop_LocalMem_Long_0
0210                           rx_tail := (rx_tail + 1) & BUFFER_MASK
0210     48            ; Push_VariableMem_Long_2
0211     36            ; Push_1
0212     EC            ; Add
0213     37 25         ; Push_Packed_Lit, $0000003F
0215     E8            ; Bit_And
0216     49            ; Pop_VariableMem_Long_2
0217     32            ; Return
                       Variables for TOP (com.serial.spin)
0218     0000          long COG
021C     0004          long RX_HEAD
0220     0008          long RX_TAIL
0224     000C          long TX_HEAD
0228     0010          long TX_TAIL
022C     0014          long RX_PIN
0230     0018          long TX_PIN
0234     001C          long RXTX_MODE
0238     0020          long BIT_TICKS
023C     0024          long BUFFER_PTR
0240     0028          byte RX_BUFFER[64]
0280     0068          byte TX_BUFFER[64]
02C0                   Reserved 8 bytes.
02C8                   Base of stack.
02D8                   Top of stack.

0000     00B71B00      Frequency 12000000 Hz
0004     00            RCFast
0005     C3            Check Sum
0006     0010          Base of Program
0008     05F8          Base of Variables
000A     0720          Base of Stack
000C     0088          Initial Program Counter
000E     0728          Initial Stack Pointer
                       File "com.serial.terminal.spin"
0010     01E0 021C     Link to Next Object
0014     0078 0000     Link to PUB Start(baudrate) : okay
0018     0084 0000     Link to PUB StartRxTx(rxpin, txpin, mode, baudrate)
001C     008E 0000     Link to PUB Stop
0020     0093 0000     Link to PUB Count
0024     0099 0000     Link to PUB Flush
0028     009E 0000     Link to PUB Char(ch)
002C     00A4 0000     Link to PUB Chars(ch, size)
0030     00AF 0000     Link to PUB CharIn
0034     00B5 0000     Link to PUB Str(stringptr)
0038     00C3 0000     Link to PUB StrIn(stringptr)
003C     00C9 0000     Link to PUB StrInMax(stringptr, maxcount)
0040     00EA 0000     Link to PUB Dec(value)
0044     00F3 0000     Link to PUB DecIn
0048     0104 0000     Link to PUB Bin(value, digits)
004C     010E 0000     Link to PUB BinIn
0050     011F 0000     Link to PUB Hex(value, digits)
0054     0129 0000     Link to PUB HexIn
0058     013A 0000     Link to PUB Clear
005C     0141 0000     Link to PUB NewLine
0060     0148 0000     Link to PUB Position(x, y)
0064     0159 0000     Link to PUB PositionX(x)
0068     0165 0000     Link to PUB PositionY(y)
006C     0171 0000     Link to PUB MoveLeft(x)
0070     017D 0000     Link to PUB MoveRight(x)
0074     0189 0000     Link to PUB MoveUp(y)
0078     0195 0000     Link to PUB MoveDown(y)
007C     01A1 0004     Link to PUB ReadLine(line, maxline) : size | c
0080                   OBJ
0080     01E0 0034         ser : "com.serial"
0084     03E8 00DC         num : "string.integer"
0088                   PUB Start(baudrate) : okay
0088                       okay := ser.Start(baudrate)
0088     00            ; Frame_Call_Return
0089     64            ; Push_LocalMem_Long_1
008A     06 1C 01      ; Objcall, $1C, $01
008D     61            ; Pop_LocalMem_Long_0
008E                       Clear
008E     01            ; Frame_Call_Noreturn
008F     05 12         ; Call, $12
0091                       return okay
0091     60            ; Push_LocalMem_Long_0
0092     33            ; Pop_Return
0093     32            ; Return
0094                   PUB StartRxTx(rxpin, txpin, mode, baudrate)
0094                       return ser.StartRxTx(rxpin, txpin, mode, baudrate)
0094     00            ; Frame_Call_Return
0095     64            ; Push_LocalMem_Long_1
0096     68            ; Push_LocalMem_Long_2
0097     6C            ; Push_LocalMem_Long_3
0098     70            ; Push_LocalMem_Long_4
0099     06 1C 02      ; Objcall, $1C, $02
009C     33            ; Pop_Return
009D     32            ; Return
009E                   PUB Stop
009E                       ser.Stop
009E     01            ; Frame_Call_Noreturn
009F     06 1C 03      ; Objcall, $1C, $03
00A2     32            ; Return
00A3                   PUB Count
00A3                       return ser.Count
00A3     00            ; Frame_Call_Return
00A4     06 1C 04      ; Objcall, $1C, $04
00A7     33            ; Pop_Return
00A8     32            ; Return
00A9                   PUB Flush
00A9                       ser.Flush
00A9     01            ; Frame_Call_Noreturn
00AA     06 1C 05      ; Objcall, $1C, $05
00AD     32            ; Return
00AE                   PUB Char(ch)
00AE                       ser.Char(ch)
00AE     01            ; Frame_Call_Noreturn
00AF     64            ; Push_LocalMem_Long_1
00B0     06 1C 06      ; Objcall, $1C, $06
00B3     32            ; Return
00B4                   PUB Chars(ch, size)
00B4                       repeat size
00B4     68            ; Push_LocalMem_Long_2
00B5     08 07         ; Loop_Start, $0007
00B7                           ser.Char(ch)
00B7     01            ; Frame_Call_Noreturn
00B8     64            ; Push_LocalMem_Long_1
00B9     06 1C 06      ; Objcall, $1C, $06
00BC     09 79         ; Loop_Continue, $FFF9
00BE     32            ; Return
00BF                   PUB CharIn
00BF                       return ser.CharIn
00BF     00            ; Frame_Call_Return
00C0     06 1C 07      ; Objcall, $1C, $07
00C3     33            ; Pop_Return
00C4     32            ; Return
00C5                   PUB Str(stringptr)
00C5                       repeat strsize(stringptr)
00C5     64            ; Push_LocalMem_Long_1
00C6     16            ; Strsize
00C7     08 09         ; Loop_Start, $0009
00C9                           ser.Char(byte[stringptr++])
00C9     01            ; Frame_Call_Noreturn
00CA     66 AE         ; Effect_LocalMem_Long_1, post-inc, long
00CC     80            ; Push_MainMem_Byte
00CD     06 1C 06      ; Objcall, $1C, $06
00D0     09 77         ; Loop_Continue, $FFF7
00D2     32            ; Return
00D3                   PUB StrIn(stringptr)
00D3                       StrInMax(stringptr, -1)
00D3     01            ; Frame_Call_Noreturn
00D4     64            ; Push_LocalMem_Long_1
00D5     34            ; Push_Neg1
00D6     05 0B         ; Call, $0B
00D8     32            ; Return
00D9                   PUB StrInMax(stringptr, maxcount)
00D9                       repeat while (maxcount--)                                                     'While maxcount not reached
00D9     6A BE         ; Effect_LocalMem_Long_2, post-dec, long
00DB     0A 11         ; Jump_If_False, $0011
00DD                           if (byte[stringptr++] := ser.CharIn) == NL                                      'Get chars until NL
00DD     00            ; Frame_Call_Return
00DE     06 1C 07      ; Objcall, $1C, $07
00E1     66 AE         ; Effect_LocalMem_Long_1, post-inc, long
00E3     82 80         ; Effect_MainMem_Byte, write, push
00E5     38 0D         ; Push_Byte_Lit, $0D
00E7     FC            ; Equal
00E8     0A 02         ; Jump_If_False, $0002
00EA                               quit
00EA     04 02         ; Branch, $0002
00EC     04 6B         ; Branch, $FFEB
00EE                       byte[stringptr+(byte[stringptr-1] == NL)]~                                    'Zero terminate string; overwrite NL or append 0 char
00EE     64            ; Push_LocalMem_Long_1
00EF     64            ; Push_LocalMem_Long_1
00F0     36            ; Push_1
00F1     ED            ; Subtract
00F2     80            ; Push_MainMem_Byte
00F3     38 0D         ; Push_Byte_Lit, $0D
00F5     FC            ; Equal
00F6     EC            ; Add
00F7     82 18         ; Effect_MainMem_Byte, post-clear
00F9     32            ; Return
00FA                   PUB Dec(value)
00FA                       Str(num.Dec(value))
00FA     01            ; Frame_Call_Noreturn
00FB     00            ; Frame_Call_Return
00FC     64            ; Push_LocalMem_Long_1
00FD     06 1D 01      ; Objcall, $1D, $01
0100     05 09         ; Call, $09
0102     32            ; Return
0103                   PUB DecIn
0103                       StrInMax(@str_buffer, MAXSTR_LENGTH)
0103     01            ; Frame_Call_Noreturn
0104     8B 00         ; Reference_VariableMem_Byte, $0000
0106     38 31         ; Push_Byte_Lit, $31
0108     05 0B         ; Call, $0B
010A                       return num.StrToBase(@str_buffer, 10)
010A     00            ; Frame_Call_Return
010B     8B 00         ; Reference_VariableMem_Byte, $0000
010D     38 0A         ; Push_Byte_Lit, $0A
010F     06 1D 08      ; Objcall, $1D, $08
0112     33            ; Pop_Return
0113     32            ; Return
0114                   PUB Bin(value, digits)
0114                       Str(num.Bin(value,digits))
0114     01            ; Frame_Call_Noreturn
0115     00            ; Frame_Call_Return
0116     64            ; Push_LocalMem_Long_1
0117     68            ; Push_LocalMem_Long_2
0118     06 1D 06      ; Objcall, $1D, $06
011B     05 09         ; Call, $09
011D     32            ; Return
011E                   PUB BinIn
011E                       StrInMax(@str_buffer, MAXSTR_LENGTH)
011E     01            ; Frame_Call_Noreturn
011F     8B 00         ; Reference_VariableMem_Byte, $0000
0121     38 31         ; Push_Byte_Lit, $31
0123     05 0B         ; Call, $0B
0125                       return num.StrToBase(@str_buffer, 2)
0125     00            ; Frame_Call_Return
0126     8B 00         ; Reference_VariableMem_Byte, $0000
0128     37 00         ; Push_Packed_Lit, $00000002
012A     06 1D 08      ; Objcall, $1D, $08
012D     33            ; Pop_Return
012E     32            ; Return
012F                   PUB Hex(value, digits)
012F                       Str(num.Hex(value, digits))
012F     01            ; Frame_Call_Noreturn
0130     00            ; Frame_Call_Return
0131     64            ; Push_LocalMem_Long_1
0132     68            ; Push_LocalMem_Long_2
0133     06 1D 04      ; Objcall, $1D, $04
0136     05 09         ; Call, $09
0138     32            ; Return
0139                   PUB HexIn
0139                       StrInMax(@str_buffer, MAXSTR_LENGTH)
0139     01            ; Frame_Call_Noreturn
013A     8B 00         ; Reference_VariableMem_Byte, $0000
013C     38 31         ; Push_Byte_Lit, $31
013E     05 0B         ; Call, $0B
0140                       return num.StrToBase(@str_buffer, 16)
0140     00            ; Frame_Call_Return
0141     8B 00         ; Reference_VariableMem_Byte, $0000
0143     37 03         ; Push_Packed_Lit, $00000010
0145     06 1D 08      ; Objcall, $1D, $08
0148     33            ; Pop_Return
0149     32            ; Return
014A                   PUB Clear
014A                       ser.Char(CS)
014A     01            ; Frame_Call_Noreturn
014B     37 03         ; Push_Packed_Lit, $00000010
014D     06 1C 06      ; Objcall, $1C, $06
0150     32            ; Return
0151                   PUB NewLine
0151                       ser.Char(NL)
0151     01            ; Frame_Call_Noreturn
0152     38 0D         ; Push_Byte_Lit, $0D
0154     06 1C 06      ; Objcall, $1C, $06
0157     32            ; Return
0158                   PUB Position(x, y)
0158                       ser.Char(PC)
0158     01            ; Frame_Call_Noreturn
0159     37 00         ; Push_Packed_Lit, $00000002
015B     06 1C 06      ; Objcall, $1C, $06
015E                       ser.Char(x)
015E     01            ; Frame_Call_Noreturn
015F     64            ; Push_LocalMem_Long_1
0160     06 1C 06      ; Objcall, $1C, $06
0163                       ser.Char(y)
0163     01            ; Frame_Call_Noreturn
0164     68            ; Push_LocalMem_Long_2
0165     06 1C 06      ; Objcall, $1C, $06
0168     32            ; Return
0169                   PUB PositionX(x)
0169                       ser.Char(PX)
0169     01            ; Frame_Call_Noreturn
016A     38 0E         ; Push_Byte_Lit, $0E
016C     06 1C 06      ; Objcall, $1C, $06
016F                       ser.Char(x)
016F     01            ; Frame_Call_Noreturn
0170     64            ; Push_LocalMem_Long_1
0171     06 1C 06      ; Objcall, $1C, $06
0174     32            ; Return
0175                   PUB PositionY(y)
0175                       ser.Char(PY)
0175     01            ; Frame_Call_Noreturn
0176     37 23         ; Push_Packed_Lit, $0000000F
0178     06 1C 06      ; Objcall, $1C, $06
017B                       ser.Char(y)
017B     01            ; Frame_Call_Noreturn
017C     64            ; Push_LocalMem_Long_1
017D     06 1C 06      ; Objcall, $1C, $06
0180     32            ; Return
0181                   PUB MoveLeft(x)
0181                       repeat x
0181     64            ; Push_LocalMem_Long_1
0182     08 08         ; Loop_Start, $0008
0184                           ser.Char(ML)
0184     01            ; Frame_Call_Noreturn
0185     37 21         ; Push_Packed_Lit, $00000003
0187     06 1C 06      ; Objcall, $1C, $06
018A     09 78         ; Loop_Continue, $FFF8
018C     32            ; Return
018D                   PUB MoveRight(x)
018D                       repeat x
018D     64            ; Push_LocalMem_Long_1
018E     08 08         ; Loop_Start, $0008
0190                           ser.Char(MR)
0190     01            ; Frame_Call_Noreturn
0191     37 01         ; Push_Packed_Lit, $00000004
0193     06 1C 06      ; Objcall, $1C, $06
0196     09 78         ; Loop_Continue, $FFF8
0198     32            ; Return
0199                   PUB MoveUp(y)
0199                       repeat y
0199     64            ; Push_LocalMem_Long_1
019A     08 08         ; Loop_Start, $0008
019C                           ser.Char(MU)
019C     01            ; Frame_Call_Noreturn
019D     38 05         ; Push_Byte_Lit, $05
019F     06 1C 06      ; Objcall, $1C, $06
01A2     09 78         ; Loop_Continue, $FFF8
01A4     32            ; Return
01A5                   PUB MoveDown(y)
01A5                       repeat y
01A5     64            ; Push_LocalMem_Long_1
01A6     08 08         ; Loop_Start, $0008
01A8                           ser.Char(MD)
01A8     01            ; Frame_Call_Noreturn
01A9     38 06         ; Push_Byte_Lit, $06
01AB     06 1C 06      ; Objcall, $1C, $06
01AE     09 78         ; Loop_Continue, $FFF8
01B0     32            ; Return
01B1                   PUB ReadLine(line, maxline) : size | c
01B1                       repeat
01B1                           case c := CharIn
01B1     39 01DC       ; Push_Word_Lit, $01DC
01B4     00            ; Frame_Call_Return
01B5     05 08         ; Call, $08
01B7     6E 80         ; Effect_LocalMem_Long_3, write, push
01B9     37 02         ; Push_Packed_Lit, $00000008
01BB     0D 17         ; Compare_Case, $0017
01BD     38 0D         ; Push_Byte_Lit, $0D
01BF     0D 1D         ; Compare_Case, $001D
01C1     38 0A         ; Push_Byte_Lit, $0A
01C3     0D 19         ; Compare_Case, $0019
01C5     60            ; Push_LocalMem_Long_0
01C6     68            ; Push_LocalMem_Long_2
01C7     F9            ; Less
01C8     0A 09         ; Jump_If_False, $0009
01CA     6C            ; Push_LocalMem_Long_3
01CB     64            ; Push_LocalMem_Long_1
01CC     62 AE         ; Effect_LocalMem_Long_0, post-inc, long
01CE     91            ; Pop_Indexed_MainMem_Byte
01CF     01            ; Frame_Call_Noreturn
01D0     6C            ; Push_LocalMem_Long_3
01D1     05 06         ; Call, $06
01D3     0C            ; Jump_From_Stack
01D4                               BS:     if size
01D4     60            ; Push_LocalMem_Long_0
01D5     0A 06         ; Jump_If_False, $0006
01D7                                           size--
01D7     62 3E         ; Effect_LocalMem_Long_0, post-dec, long
01D9                                           Char(c)
01D9     01            ; Frame_Call_Noreturn
01DA     6C            ; Push_LocalMem_Long_3
01DB     05 06         ; Call, $06
01DD     0C            ; Jump_From_Stack
01DE                               NL, LF: byte[line][size] := 0
01DE     35            ; Push_0
01DF     64            ; Push_LocalMem_Long_1
01E0     60            ; Push_LocalMem_Long_0
01E1     91            ; Pop_Indexed_MainMem_Byte
01E2                                       Char(c)
01E2     01            ; Frame_Call_Noreturn
01E3     6C            ; Push_LocalMem_Long_3
01E4     05 06         ; Call, $06
01E6                                       quit
01E6     37 02         ; Push_Packed_Lit, $00000008
01E8     14            ; Quit
01E9     04 03         ; Branch, $0003
01EB     0C            ; Jump_From_Stack
01EC                               other:  if size < maxline
01EC     04 43         ; Branch, $FFC3
01EE     32            ; Return
01EF     00            ; Frame_Call_Return
                       File "com.serial.spin"
01F0     0208 0009     Link to Next Object
01F4     0174 0000     Link to PUB Start(baudrate) : okay
01F8     017F 0000     Link to PUB StartRxTx(rxpin, txpin, mode, baudrate) : okay
01FC     01A1 0000     Link to PUB Stop
0200     01AF 0000     Link to PUB Count
0204     01BE 0000     Link to PUB Flush
0208     01C8 0000     Link to PUB Char(ch)
020C     01E9 0000     Link to PUB CharIn
0210     01F5 0000     Link to PRI RxCheck
0214 000               DAT
0214 000                                       org
0214 000 A0BCA9F0      entry                   mov     t1,par                'get structure address
0218 001 80FCA810                              add     t1,#4 << 2            'skip past heads and tails
021C 002 08BCAA54                              rdlong  t2,t1                 'get rx_pin
0220 003 A0FCB201                              mov     rxmask,#1
0224 004 2CBCB255                              shl     rxmask,t2
0228 005 80FCA804                              add     t1,#4                 'get tx_pin
022C 006 08BCAA54                              rdlong  t2,t1
0230 007 A0FCBE01                              mov     txmask,#1
0234 008 2CBCBE55                              shl     txmask,t2
0238 009 80FCA804                              add     t1,#4                 'get rxtx_mode
023C 00A 08BCAE54                              rdlong  rxtxmode,t1
0240 00B 80FCA804                              add     t1,#4                 'get bit_ticks
0244 00C 08BCB054                              rdlong  bitticks,t1
0248 00D 80FCA804                              add     t1,#4                 'get buffer_ptr
024C 00E 08BCB454                              rdlong  rxbuff,t1
0250 00F A0BCC05A                              mov     txbuff,rxbuff
0254 010 80FCC040                              add     txbuff,#BUFFER_LENGTH
0258 011 627CAE04                              test    rxtxmode,#%100  wz    'init tx pin according to mode
025C 012 617CAE02                              test    rxtxmode,#%010  wc
0260 013 689BE85F              if_z_ne_c       or      outa,txmask
0264 014 68ABEC5F              if_z            or      dira,txmask
0268 015 A0FCC833                              mov     txcode,#transmit      'initialize ping-pong multitasking
026C 016 5CBCBC64      receive                 jmpret  rxcode,txcode         'run chunk of tx code, then return
0270 017 627CAE01                              test    rxtxmode,#%001  wz    'wait for start bit on rx pin
0274 018 613CB3F2                              test    rxmask,ina      wc
0278 019 5C640016              if_z_eq_c       jmp     #receive
027C 01A A0FCB809                              mov     rxbits,#9             'ready to receive byte
0280 01B A0BCBA58                              mov     rxcnt,bitticks
0284 01C 28FCBA01                              shr     rxcnt,#1
0288 01D 80BCBBF1                              add     rxcnt,cnt
028C 01E 80BCBA58      :bit                    add     rxcnt,bitticks        'ready next bit period
0290 01F 5CBCBC64      :wait                   jmpret  rxcode,txcode         'run chunk of tx code, then return
0294 020 A0BCA85D                              mov     t1,rxcnt              'check if bit receive period done
0298 021 84BCA9F1                              sub     t1,cnt
029C 022 C17CA800                              cmps    t1,#0           wc
02A0 023 5C4C001F              if_nc           jmp     #:wait
02A4 024 613CB3F2                              test    rxmask,ina      wc    'receive bit on rx pin
02A8 025 30FCB601                              rcr     rxdata,#1
02AC 026 E4FCB81E                              djnz    rxbits,#:bit
02B0 027 28FCB617                              shr     rxdata,#32-9          'justify and trim received byte
02B4 028 60FCB6FF                              and     rxdata,#$FF
02B8 029 627CAE01                              test    rxtxmode,#%001  wz    'if rx inverted, invert byte
02BC 02A 6CD4B6FF              if_nz           xor     rxdata,#$FF
02C0 02B 08BCABF0                              rdlong  t2,par                'save received byte and inc head
02C4 02C 80BCAA5A                              add     t2,rxbuff
02C8 02D 003CB655                              wrbyte  rxdata,t2
02CC 02E 84BCAA5A                              sub     t2,rxbuff
02D0 02F 80FCAA01                              add     t2,#1
02D4 030 60FCAA3F                              and     t2,#BUFFER_MASK
02D8 031 083CABF0                              wrlong  t2,par
02DC 032 5C7C0016                              jmp     #receive              'byte done, receive next byte
02E0 033 5CBCC85E      transmit                jmpret  txcode,rxcode         'run chunk of rx code, then return
02E4 034 A0BCA9F0                              mov     t1,par                'check for head <> tail
02E8 035 80FCA808                              add     t1,#2 << 2
02EC 036 08BCAA54                              rdlong  t2,t1
02F0 037 80FCA804                              add     t1,#1 << 2
02F4 038 08BCAC54                              rdlong  t3,t1
02F8 039 863CAA56                              cmp     t2,t3           wz
02FC 03A 5C680033              if_z            jmp     #transmit
0300 03B 80BCAC60                              add     t3,txbuff             'get byte and inc tail
0304 03C 00BCC256                              rdbyte  txdata,t3
0308 03D 84BCAC60                              sub     t3,txbuff
030C 03E 80FCAC01                              add     t3,#1
0310 03F 60FCAC3F                              and     t3,#BUFFER_MASK
0314 040 083CAC54                              wrlong  t3,t1
0318 041 68FCC300                              or      txdata,#$100          'ready byte to transmit
031C 042 2CFCC202                              shl     txdata,#2
0320 043 68FCC201                              or      txdata,#1
0324 044 A0FCC40B                              mov     txbits,#11
0328 045 A0BCC7F1                              mov     txcnt,cnt
032C 046 627CAE04      :bit                    test    rxtxmode,#%100  wz    'output bit on tx pin
0330 047 617CAE02                              test    rxtxmode,#%010  wc    'according to mode
0334 048 6CE0C201              if_z_and_c      xor     txdata,#1
0338 049 29FCC201                              shr     txdata,#1       wc
033C 04A 70ABE85F              if_z            muxc    outa,txmask
0340 04B 7497EC5F              if_nz           muxnc   dira,txmask
0344 04C 80BCC658                              add     txcnt,bitticks        'ready next cnt
0348 04D 5CBCC85E      :wait                   jmpret  txcode,rxcode         'run chunk of rx code, then return
034C 04E A0BCA863                              mov     t1,txcnt              'check if bit transmit period done
0350 04F 84BCA9F1                              sub     t1,cnt
0354 050 C17CA800                              cmps    t1,#0           wc
0358 051 5C4C004D              if_nc           jmp     #:wait
035C 052 E4FCC446                              djnz    txbits,#:bit          'another bit to transmit?
0360 053 5C7C0033                              jmp     #transmit             'byte done, transmit next byte
0364 054               t1                      res     1
0364 055               t2                      res     1
0364 056               t3                      res     1
0364 057               rxtxmode                res     1
0364 058               bitticks                res     1
0364 059               rxmask                  res     1
0364 05A               rxbuff                  res     1
0364 05B               rxdata                  res     1
0364 05C               rxbits                  res     1
0364 05D               rxcnt                   res     1
0364 05E               rxcode                  res     1
0364 05F               txmask                  res     1
0364 060               txbuff                  res     1
0364 061               txdata                  res     1
0364 062               txbits                  res     1
0364 063               txcnt                   res     1
0364 064               txcode                  res     1
0364                   PUB Start(baudrate) : okay
0364                       okay := StartRxTx(31, 30, 0, baudrate)
0364     00            ; Frame_Call_Return
0365     37 24         ; Push_Packed_Lit, $0000001F
0367     38 1E         ; Push_Byte_Lit, $1E
0369     35            ; Push_0
036A     64            ; Push_LocalMem_Long_1
036B     05 02         ; Call, $02
036D     61            ; Pop_LocalMem_Long_0
036E     32            ; Return
036F                   PUB StartRxTx(rxpin, txpin, mode, baudrate) : okay
036F                       Stop
036F     01            ; Frame_Call_Noreturn
0370     05 03         ; Call, $03
0372                       longfill(@rx_head, 0, 4)
0372     47            ; Reference_VariableMem_Long_1
0373     35            ; Push_0
0374     37 01         ; Push_Packed_Lit, $00000004
0376     1A            ; Longfill
0377                       longmove(@rx_pin, @rxpin, 3)
0377     57            ; Reference_VariableMem_Long_5
0378     67            ; Reference_LocalMem_Long_1
0379     37 21         ; Push_Packed_Lit, $00000003
037B     1E            ; Longmove
037C                       bit_ticks := clkfreq / baudrate
037C     35            ; Push_0
037D     C0            ; Push_MainMem_Long
037E     70            ; Push_LocalMem_Long_4
037F     F6            ; Divide
0380     C9 20         ; Pop_VariableMem_Long, $0020
0382                       buffer_ptr := @rx_buffer
0382     8B 28         ; Reference_VariableMem_Byte, $0028
0384     C9 24         ; Pop_VariableMem_Long, $0024
0386                       okay := cog := cognew(@entry, @rx_head) + 1
0386     34            ; Push_Neg1
0387     C7 24         ; Reference_ObjectMem_Long, $0024
0389     47            ; Reference_VariableMem_Long_1
038A     28            ; Coginit_Returns
038B     36            ; Push_1
038C     EC            ; Add
038D     42 80         ; Effect_VariableMem_Long_0, write, push
038F     61            ; Pop_LocalMem_Long_0
0390     32            ; Return
0391                   PUB Stop
0391                       if cog
0391     40            ; Push_VariableMem_Long_0
0392     0A 05         ; Jump_If_False, $0005
0394                           cogstop(cog~ - 1)
0394     42 98         ; Effect_VariableMem_Long_0, post-clear, push
0396     36            ; Push_1
0397     ED            ; Subtract
0398     21            ; Cogstop
0399                       longfill(@rx_head, 0, 9)
0399     47            ; Reference_VariableMem_Long_1
039A     35            ; Push_0
039B     38 09         ; Push_Byte_Lit, $09
039D     1A            ; Longfill
039E     32            ; Return
039F                   PUB Count
039F                       result := rx_head - rx_tail
039F     44            ; Push_VariableMem_Long_1
03A0     48            ; Push_VariableMem_Long_2
03A1     ED            ; Subtract
03A2     61            ; Pop_LocalMem_Long_0
03A3                       result -= BUFFER_LENGTH*(Count < 0)
03A3     37 05         ; Push_Packed_Lit, $00000040
03A5     00            ; Frame_Call_Return
03A6     05 04         ; Call, $04
03A8     35            ; Push_0
03A9     F9            ; Less
03AA     F4            ; Multiply
03AB     62 4D         ; Effect_LocalMem_Long_0, Subtract, swap
03AD     32            ; Return
03AE                   PUB Flush
03AE                       repeat while RxCheck => 0
03AE     00            ; Frame_Call_Return
03AF     05 08         ; Call, $08
03B1     35            ; Push_0
03B2     FE            ; Greater_Equal
03B3     0A 02         ; Jump_If_False, $0002
03B5     04 77         ; Branch, $FFF7
03B7     32            ; Return
03B8                   PUB Char(ch)
03B8                       repeat until (tx_tail <> ((tx_head + 1) & BUFFER_MASK))
03B8     50            ; Push_VariableMem_Long_4
03B9     4C            ; Push_VariableMem_Long_3
03BA     36            ; Push_1
03BB     EC            ; Add
03BC     37 25         ; Push_Packed_Lit, $0000003F
03BE     E8            ; Bit_And
03BF     FB            ; Not_Equal
03C0     0B 02         ; Jump_If_True, $0002
03C2     04 74         ; Branch, $FFF4
03C4                       tx_buffer[tx_head] := ch
03C4     64            ; Push_LocalMem_Long_1
03C5     4C            ; Push_VariableMem_Long_3
03C6     99 68         ; Pop_Indexed_VariableMem_Byte, $0068
03C8                       tx_head := (tx_head + 1) & BUFFER_MASK
03C8     4C            ; Push_VariableMem_Long_3
03C9     36            ; Push_1
03CA     EC            ; Add
03CB     37 25         ; Push_Packed_Lit, $0000003F
03CD     E8            ; Bit_And
03CE     4D            ; Pop_VariableMem_Long_3
03CF                       if rxtx_mode & %1000
03CF     5C            ; Push_VariableMem_Long_7
03D0     37 02         ; Push_Packed_Lit, $00000008
03D2     E8            ; Bit_And
03D3     0A 03         ; Jump_If_False, $0003
03D5                           CharIn
03D5     01            ; Frame_Call_Noreturn
03D6     05 07         ; Call, $07
03D8     32            ; Return
03D9                   PUB CharIn
03D9                       repeat while (result := RxCheck) < 0
03D9     00            ; Frame_Call_Return
03DA     05 08         ; Call, $08
03DC     62 80         ; Effect_LocalMem_Long_0, write, push
03DE     35            ; Push_0
03DF     F9            ; Less
03E0     0A 02         ; Jump_If_False, $0002
03E2     04 75         ; Branch, $FFF5
03E4     32            ; Return
03E5                   PRI RxCheck
03E5                       result~~
03E5     62 1C         ; Effect_LocalMem_Long_0, post-set
03E7                       if rx_tail <> rx_head
03E7     48            ; Push_VariableMem_Long_2
03E8     44            ; Push_VariableMem_Long_1
03E9     FB            ; Not_Equal
03EA     0A 0B         ; Jump_If_False, $000B
03EC                           result := rx_buffer[rx_tail]
03EC     48            ; Push_VariableMem_Long_2
03ED     98 28         ; Push_Indexed_VariableMem_Byte, $0028
03EF     61            ; Pop_LocalMem_Long_0
03F0                           rx_tail := (rx_tail + 1) & BUFFER_MASK
03F0     48            ; Push_VariableMem_Long_2
03F1     36            ; Push_1
03F2     EC            ; Add
03F3     37 25         ; Push_Packed_Lit, $0000003F
03F5     E8            ; Bit_And
03F6     49            ; Pop_VariableMem_Long_2
03F7     32            ; Return
                       File "string.integer.spin"
03F8     0200 000D     Link to Next Object
03FC     0034 0000     Link to PUB Dec(value)
0400     0041 0008     Link to PUB DecPadded(value, width) | t_val, field
0404     0083 0004     Link to PUB DecZeroed(value, digits) | div
0408     00D6 0000     Link to PUB Hex(value, digits)
040C     00E4 0000     Link to PUB HexIndicated(value, digits)
0410     00F8 0000     Link to PUB Bin(value, digits)
0414     0106 0000     Link to PUB BinIndicated(value, digits)
0418     011A 0008     Link to PUB StrToBase(stringptr, base) : value | chr, index
041C     015B 0000     Link to PRI ClearStr(strAddr, size)
0420     0162 0008     Link to PRI DecToStr(value) | div, z_pad
0424     01A8 0000     Link to PRI HexToStr(value, digits)
0428     01DB 0000     Link to PRI BinToStr(value, digits)
042C                   PUB Dec(value)
042C                       ClearStr(@nstr, MAX_LEN)                                ' clear output string
042C     01            ; Frame_Call_Noreturn
042D     8B 04         ; Reference_VariableMem_Byte, $0004
042F     37 05         ; Push_Packed_Lit, $00000040
0431     05 09         ; Call, $09
0433                       return DecToStr(value)                                  ' return pointer to numeric string
0433     00            ; Frame_Call_Return
0434     64            ; Push_LocalMem_Long_1
0435     05 0A         ; Call, $0A
0437     33            ; Pop_Return
0438     32            ; Return
0439                   PUB DecPadded(value, width) | t_val, field
0439                       ClearStr(@nstr, MAX_LEN)
0439     01            ; Frame_Call_Noreturn
043A     8B 04         ; Reference_VariableMem_Byte, $0004
043C     37 05         ; Push_Packed_Lit, $00000040
043E     05 09         ; Call, $09
0440                       width := 1 #> width <# constant(MAX_LEN - 1)          ' qualify field width
0440     36            ; Push_1
0441     68            ; Push_LocalMem_Long_2
0442     E4            ; Limit_Min
0443     37 25         ; Push_Packed_Lit, $0000003F
0445     E5            ; Limit_Max
0446     69            ; Pop_LocalMem_Long_2
0447                       t_val := ||value                                      ' work with absolute
0447     64            ; Push_LocalMem_Long_1
0448     E9            ; Absolute_Value
0449     6D            ; Pop_LocalMem_Long_3
044A                       field~                                                ' clear field
044A     72 18         ; Effect_LocalMem_Long_4, post-clear
044C                       repeat while t_val > 0                                ' count number of digits
044C     6C            ; Push_LocalMem_Long_3
044D     35            ; Push_0
044E     FA            ; Greater
044F     0A 08         ; Jump_If_False, $0008
0451                           field++
0451     72 2E         ; Effect_LocalMem_Long_4, post-inc, long
0453                           t_val /= 10
0453     38 0A         ; Push_Byte_Lit, $0A
0455     6E 56         ; Effect_LocalMem_Long_3, Divide, swap
0457     04 73         ; Branch, $FFF3
0459                       field #>= 1                                           ' min field width is 1
0459     36            ; Push_1
045A     72 44         ; Effect_LocalMem_Long_4, Limit_Min, swap
045C                       if value < 0                                          ' if value is negative
045C     64            ; Push_LocalMem_Long_1
045D     35            ; Push_0
045E     F9            ; Less
045F     0A 02         ; Jump_If_False, $0002
0461                           field++                                             '   bump field for neg sign indicator
0461     72 2E         ; Effect_LocalMem_Long_4, post-inc, long
0463                       if field < width                                      ' need padding?
0463     70            ; Push_LocalMem_Long_4
0464     68            ; Push_LocalMem_Long_2
0465     F9            ; Less
0466     0A 0D         ; Jump_If_False, $000D
0468                           repeat (width - field)                              ' yes
0468     68            ; Push_LocalMem_Long_2
0469     70            ; Push_LocalMem_Long_4
046A     ED            ; Subtract
046B     08 08         ; Loop_Start, $0008
046D                               nstr[idx++] := " "                                '   pad with space(s)
046D     37 04         ; Push_Packed_Lit, $00000020
046F     42 AE         ; Effect_VariableMem_Long_0, post-inc, long
0471     99 04         ; Pop_Indexed_VariableMem_Byte, $0004
0473     09 78         ; Loop_Continue, $FFF8
0475                       return DecToStr(value)
0475     00            ; Frame_Call_Return
0476     64            ; Push_LocalMem_Long_1
0477     05 0A         ; Call, $0A
0479     33            ; Pop_Return
047A     32            ; Return
047B                   PUB DecZeroed(value, digits) | div
047B                       ClearStr(@nstr, MAX_LEN)
047B     01            ; Frame_Call_Noreturn
047C     8B 04         ; Reference_VariableMem_Byte, $0004
047E     37 05         ; Push_Packed_Lit, $00000040
0480     05 09         ; Call, $09
0482                       digits := 1 #> digits <# 10
0482     36            ; Push_1
0483     68            ; Push_LocalMem_Long_2
0484     E4            ; Limit_Min
0485     38 0A         ; Push_Byte_Lit, $0A
0487     E5            ; Limit_Max
0488     69            ; Pop_LocalMem_Long_2
0489                       if (value < 0)                                        ' negative value?
0489     64            ; Push_LocalMem_Long_1
048A     35            ; Push_0
048B     F9            ; Less
048C     0A 08         ; Jump_If_False, $0008
048E                           -value                                              '   yes, make positive
048E     66 46         ; Effect_LocalMem_Long_1, Negate, swap
0490                           nstr[idx++] := "-"                                  '   and print sign indicator
0490     38 2D         ; Push_Byte_Lit, $2D
0492     42 AE         ; Effect_VariableMem_Long_0, post-inc, long
0494     99 04         ; Pop_Indexed_VariableMem_Byte, $0004
0496                       div := 1_000_000_000                                  ' initialize divisor
0496     3B 3B9ACA00   ; Push_Long_Lit, $3B9ACA00
049B     6D            ; Pop_LocalMem_Long_3
049C                       if digits < 10                                        ' less than 10 digits?
049C     68            ; Push_LocalMem_Long_2
049D     38 0A         ; Push_Byte_Lit, $0A
049F     F9            ; Less
04A0     0A 0C         ; Jump_If_False, $000C
04A2                           repeat (10 - digits)                                '   yes, adjust divisor
04A2     38 0A         ; Push_Byte_Lit, $0A
04A4     68            ; Push_LocalMem_Long_2
04A5     ED            ; Subtract
04A6     08 06         ; Loop_Start, $0006
04A8                               div /= 10
04A8     38 0A         ; Push_Byte_Lit, $0A
04AA     6E 56         ; Effect_LocalMem_Long_3, Divide, swap
04AC     09 7A         ; Loop_Continue, $FFFA
04AE                       value //= (div * 10)                                  ' truncate unused digits
04AE     6C            ; Push_LocalMem_Long_3
04AF     38 0A         ; Push_Byte_Lit, $0A
04B1     F4            ; Multiply
04B2     66 57         ; Effect_LocalMem_Long_1, Modulo, swap
04B4                       repeat digits
04B4     68            ; Push_LocalMem_Long_2
04B5     08 13         ; Loop_Start, $0013
04B7                           nstr[idx++] := (value / div + "0")                  ' convert digit to ASCII
04B7     64            ; Push_LocalMem_Long_1
04B8     6C            ; Push_LocalMem_Long_3
04B9     F6            ; Divide
04BA     38 30         ; Push_Byte_Lit, $30
04BC     EC            ; Add
04BD     42 AE         ; Effect_VariableMem_Long_0, post-inc, long
04BF     99 04         ; Pop_Indexed_VariableMem_Byte, $0004
04C1                           value //= div                                       ' update value
04C1     6C            ; Push_LocalMem_Long_3
04C2     66 57         ; Effect_LocalMem_Long_1, Modulo, swap
04C4                           div /= 10                                           ' update divisor
04C4     38 0A         ; Push_Byte_Lit, $0A
04C6     6E 56         ; Effect_LocalMem_Long_3, Divide, swap
04C8     09 6D         ; Loop_Continue, $FFED
04CA                       return @nstr
04CA     8B 04         ; Reference_VariableMem_Byte, $0004
04CC     33            ; Pop_Return
04CD     32            ; Return
04CE                   PUB Hex(value, digits)
04CE                       ClearStr(@nstr, MAX_LEN)
04CE     01            ; Frame_Call_Noreturn
04CF     8B 04         ; Reference_VariableMem_Byte, $0004
04D1     37 05         ; Push_Packed_Lit, $00000040
04D3     05 09         ; Call, $09
04D5                       return HexToStr(value, digits)
04D5     00            ; Frame_Call_Return
04D6     64            ; Push_LocalMem_Long_1
04D7     68            ; Push_LocalMem_Long_2
04D8     05 0B         ; Call, $0B
04DA     33            ; Pop_Return
04DB     32            ; Return
04DC                   PUB HexIndicated(value, digits)
04DC                       ClearStr(@nstr, MAX_LEN)
04DC     01            ; Frame_Call_Noreturn
04DD     8B 04         ; Reference_VariableMem_Byte, $0004
04DF     37 05         ; Push_Packed_Lit, $00000040
04E1     05 09         ; Call, $09
04E3                       nstr[idx++] := "$"
04E3     38 24         ; Push_Byte_Lit, $24
04E5     42 AE         ; Effect_VariableMem_Long_0, post-inc, long
04E7     99 04         ; Pop_Indexed_VariableMem_Byte, $0004
04E9                       return HexToStr(value, digits)
04E9     00            ; Frame_Call_Return
04EA     64            ; Push_LocalMem_Long_1
04EB     68            ; Push_LocalMem_Long_2
04EC     05 0B         ; Call, $0B
04EE     33            ; Pop_Return
04EF     32            ; Return
04F0                   PUB Bin(value, digits)
04F0                       ClearStr(@nstr, MAX_LEN)
04F0     01            ; Frame_Call_Noreturn
04F1     8B 04         ; Reference_VariableMem_Byte, $0004
04F3     37 05         ; Push_Packed_Lit, $00000040
04F5     05 09         ; Call, $09
04F7                       return BinToStr(value, digits)
04F7     00            ; Frame_Call_Return
04F8     64            ; Push_LocalMem_Long_1
04F9     68            ; Push_LocalMem_Long_2
04FA     05 0C         ; Call, $0C
04FC     33            ; Pop_Return
04FD     32            ; Return
04FE                   PUB BinIndicated(value, digits)
04FE                       ClearStr(@nstr, MAX_LEN)
04FE     01            ; Frame_Call_Noreturn
04FF     8B 04         ; Reference_VariableMem_Byte, $0004
0501     37 05         ; Push_Packed_Lit, $00000040
0503     05 09         ; Call, $09
0505                       nstr[idx++] := "%"                                    ' preface with binary indicator
0505     38 25         ; Push_Byte_Lit, $25
0507     42 AE         ; Effect_VariableMem_Long_0, post-inc, long
0509     99 04         ; Pop_Indexed_VariableMem_Byte, $0004
050B                       return BinToStr(value, digits)
050B     00            ; Frame_Call_Return
050C     64            ; Push_LocalMem_Long_1
050D     68            ; Push_LocalMem_Long_2
050E     05 0C         ; Call, $0C
0510     33            ; Pop_Return
0511     32            ; Return
0512                   PUB StrToBase(stringptr, base) : value | chr, index
0512                       value := index := 0
0512     35            ; Push_0
0513     72 80         ; Effect_LocalMem_Long_4, write, push
0515     61            ; Pop_LocalMem_Long_0
0516                       repeat until ((chr := byte[stringptr][index++]) == 0)
0516     64            ; Push_LocalMem_Long_1
0517     72 AE         ; Effect_LocalMem_Long_4, post-inc, long
0519     90            ; Push_Indexed_MainMem_Byte
051A     6E 80         ; Effect_LocalMem_Long_3, write, push
051C     35            ; Push_0
051D     FC            ; Equal
051E     0B 23         ; Jump_If_True, $0023
0520                           chr := -15 + --chr & %11011111 + 39*(chr > 56)                      ' Make "0"-"9","A"-"F","a"-"f" be 0 - 15, others out of range
0520     38 0E         ; Push_Byte_Lit, $0E
0522     E7            ; Complement
0523     6E B6         ; Effect_LocalMem_Long_3, pre-dec, long
0525     38 DF         ; Push_Byte_Lit, $DF
0527     E8            ; Bit_And
0528     EC            ; Add
0529     38 27         ; Push_Byte_Lit, $27
052B     6C            ; Push_LocalMem_Long_3
052C     38 38         ; Push_Byte_Lit, $38
052E     FA            ; Greater
052F     F4            ; Multiply
0530     EC            ; Add
0531     6D            ; Pop_LocalMem_Long_3
0532                           if (chr > -1) and (chr < base)                                      ' Accumulate valid values into result; ignore others
0532     6C            ; Push_LocalMem_Long_3
0533     34            ; Push_Neg1
0534     FA            ; Greater
0535     6C            ; Push_LocalMem_Long_3
0536     68            ; Push_LocalMem_Long_2
0537     F9            ; Less
0538     F0            ; Logical_And
0539     0A 06         ; Jump_If_False, $0006
053B                               value := value * base + chr
053B     60            ; Push_LocalMem_Long_0
053C     68            ; Push_LocalMem_Long_2
053D     F4            ; Multiply
053E     6C            ; Push_LocalMem_Long_3
053F     EC            ; Add
0540     61            ; Pop_LocalMem_Long_0
0541     04 53         ; Branch, $FFD3
0543                       if (base == 10) and (byte[stringptr] == "-")                            ' If decimal, address negative sign; ignore otherwise
0543     68            ; Push_LocalMem_Long_2
0544     38 0A         ; Push_Byte_Lit, $0A
0546     FC            ; Equal
0547     64            ; Push_LocalMem_Long_1
0548     80            ; Push_MainMem_Byte
0549     38 2D         ; Push_Byte_Lit, $2D
054B     FC            ; Equal
054C     F0            ; Logical_And
054D     0A 03         ; Jump_If_False, $0003
054F                           value := - value
054F     60            ; Push_LocalMem_Long_0
0550     E6            ; Negate
0551     61            ; Pop_LocalMem_Long_0
0552     32            ; Return
0553                   PRI ClearStr(strAddr, size)
0553                       bytefill(strAddr, 0, size)                            ' clear string to zeros
0553     64            ; Push_LocalMem_Long_1
0554     35            ; Push_0
0555     68            ; Push_LocalMem_Long_2
0556     18            ; Bytefill
0557                       idx~                                                  ' reset index
0557     42 18         ; Effect_VariableMem_Long_0, post-clear
0559     32            ; Return
055A                   PRI DecToStr(value) | div, z_pad
055A                       if (value < 0)                                        ' negative value?
055A     64            ; Push_LocalMem_Long_1
055B     35            ; Push_0
055C     F9            ; Less
055D     0A 08         ; Jump_If_False, $0008
055F                           -value                                              '   yes, make positive
055F     66 46         ; Effect_LocalMem_Long_1, Negate, swap
0561                           nstr[idx++] := "-"                                  '   and print sign indicator
0561     38 2D         ; Push_Byte_Lit, $2D
0563     42 AE         ; Effect_VariableMem_Long_0, post-inc, long
0565     99 04         ; Pop_Indexed_VariableMem_Byte, $0004
0567                       div := 1_000_000_000                                  ' initialize divisor
0567     3B 3B9ACA00   ; Push_Long_Lit, $3B9ACA00
056C     69            ; Pop_LocalMem_Long_2
056D                       z_pad~                                                ' clear zero-pad flag
056D     6E 18         ; Effect_LocalMem_Long_3, post-clear
056F                       repeat 10
056F     38 0A         ; Push_Byte_Lit, $0A
0571     08 29         ; Loop_Start, $0029
0573                           if (value => div)                                   ' printable character?
0573     64            ; Push_LocalMem_Long_1
0574     68            ; Push_LocalMem_Long_2
0575     FE            ; Greater_Equal
0576     0A 11         ; Jump_If_False, $0011
0578                               nstr[idx++] := (value / div + "0")                '   yes, print ASCII digit
0578     64            ; Push_LocalMem_Long_1
0579     68            ; Push_LocalMem_Long_2
057A     F6            ; Divide
057B     38 30         ; Push_Byte_Lit, $30
057D     EC            ; Add
057E     42 AE         ; Effect_VariableMem_Long_0, post-inc, long
0580     99 04         ; Pop_Indexed_VariableMem_Byte, $0004
0582                               value //= div                                     '   update value
0582     68            ; Push_LocalMem_Long_2
0583     66 57         ; Effect_LocalMem_Long_1, Modulo, swap
0585                               z_pad~~                                           '   set zflag
0585     6E 1C         ; Effect_LocalMem_Long_3, post-set
0587     04 0D         ; Branch, $000D
0589     6C            ; Push_LocalMem_Long_3
058A     68            ; Push_LocalMem_Long_2
058B     36            ; Push_1
058C     FC            ; Equal
058D     F2            ; Logical_Or
058E     0A 06         ; Jump_If_False, $0006
0590                               nstr[idx++] := "0"
0590     38 30         ; Push_Byte_Lit, $30
0592     42 AE         ; Effect_VariableMem_Long_0, post-inc, long
0594     99 04         ; Pop_Indexed_VariableMem_Byte, $0004
0596                           div /= 10
0596     38 0A         ; Push_Byte_Lit, $0A
0598     6A 56         ; Effect_LocalMem_Long_2, Divide, swap
059A     09 57         ; Loop_Continue, $FFD7
059C                       return @nstr
059C     8B 04         ; Reference_VariableMem_Byte, $0004
059E     33            ; Pop_Return
059F     32            ; Return
05A0                   PRI HexToStr(value, digits)
05A0                       digits := 1 #> digits <# 8                            ' qualify digits
05A0     36            ; Push_1
05A1     68            ; Push_LocalMem_Long_2
05A2     E4            ; Limit_Min
05A3     37 02         ; Push_Packed_Lit, $00000008
05A5     E5            ; Limit_Max
05A6     69            ; Pop_LocalMem_Long_2
05A7                       value <<= (8 - digits) << 2                           ' prep most significant digit
05A7     37 02         ; Push_Packed_Lit, $00000008
05A9     68            ; Push_LocalMem_Long_2
05AA     ED            ; Subtract
05AB     37 00         ; Push_Packed_Lit, $00000002
05AD     E3            ; Shift_Left
05AE     66 43         ; Effect_LocalMem_Long_1, Shift_Left, swap
05B0                       repeat digits
05B0     68            ; Push_LocalMem_Long_2
05B1     08 1C         ; Loop_Start, $001C
05B3                           nstr[idx++] := lookupz((value <-= 4) & $F : "0".."9", "A".."F")
05B3     35            ; Push_0
05B4     39 01D1       ; Push_Word_Lit, $01D1
05B7     37 01         ; Push_Packed_Lit, $00000004
05B9     66 C1         ; Effect_LocalMem_Long_1, Rotate_Left, swap
05BB     37 23         ; Push_Packed_Lit, $0000000F
05BD     E8            ; Bit_And
05BE     38 30         ; Push_Byte_Lit, $30
05C0     38 39         ; Push_Byte_Lit, $39
05C2     12            ; Lookuprange_Compare
05C3     38 41         ; Push_Byte_Lit, $41
05C5     38 46         ; Push_Byte_Lit, $46
05C7     12            ; Lookuprange_Compare
05C8     0F            ; Look_Abort
05C9     42 AE         ; Effect_VariableMem_Long_0, post-inc, long
05CB     99 04         ; Pop_Indexed_VariableMem_Byte, $0004
05CD     09 64         ; Loop_Continue, $FFE4
05CF                       return @nstr
05CF     8B 04         ; Reference_VariableMem_Byte, $0004
05D1     33            ; Pop_Return
05D2     32            ; Return
05D3                   PRI BinToStr(value, digits)
05D3                       digits := 1 #> digits <# 32                           ' qualify digits
05D3     36            ; Push_1
05D4     68            ; Push_LocalMem_Long_2
05D5     E4            ; Limit_Min
05D6     37 04         ; Push_Packed_Lit, $00000020
05D8     E5            ; Limit_Max
05D9     69            ; Pop_LocalMem_Long_2
05DA                       value <<= 32 - digits                                 ' prep MSB
05DA     37 04         ; Push_Packed_Lit, $00000020
05DC     68            ; Push_LocalMem_Long_2
05DD     ED            ; Subtract
05DE     66 43         ; Effect_LocalMem_Long_1, Shift_Left, swap
05E0                       repeat digits
05E0     68            ; Push_LocalMem_Long_2
05E1     08 0E         ; Loop_Start, $000E
05E3                           nstr[idx++] := (value <-= 1) & 1 + "0"              ' move digits (ASCII) to string
05E3     36            ; Push_1
05E4     66 C1         ; Effect_LocalMem_Long_1, Rotate_Left, swap
05E6     36            ; Push_1
05E7     E8            ; Bit_And
05E8     38 30         ; Push_Byte_Lit, $30
05EA     EC            ; Add
05EB     42 AE         ; Effect_VariableMem_Long_0, post-inc, long
05ED     99 04         ; Pop_Indexed_VariableMem_Byte, $0004
05EF     09 72         ; Loop_Continue, $FFF2
05F1                       return @nstr
05F1     8B 04         ; Reference_VariableMem_Byte, $0004
05F3     33            ; Pop_Return
05F4     32            ; Return
05F5     00            ; Frame_Call_Return
05F6     00            ; Frame_Call_Return
05F7     00            ; Frame_Call_Return
                       Variables for TOP (com.serial.terminal.spin)
05F8     0000          byte STR_BUFFER[50]
                       Variables for TOP.SER (com.serial.spin)
062C     0000          long COG
0630     0004          long RX_HEAD
0634     0008          long RX_TAIL
0638     000C          long TX_HEAD
063C     0010          long TX_TAIL
0640     0014          long RX_PIN
0644     0018          long TX_PIN
0648     001C          long RXTX_MODE
064C     0020          long BIT_TICKS
0650     0024          long BUFFER_PTR
0654     0028          byte RX_BUFFER[64]
0694     0068          byte TX_BUFFER[64]
                       Variables for TOP.NUM (string.integer.spin)
06D4     0000          long IDX
06D8     0004          byte NSTR[64]
0718                   Reserved 8 bytes.
0720                   Base of stack.
0730                   Top of stack.

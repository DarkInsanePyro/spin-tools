0000     00B71B00      Frequency 12000000 Hz
0004     00            RCFast
0005     19            Check Sum
0006     0010          Base of Program
0008     0318          Base of Variables
000A     032C          Base of Stack
000C     02AC          Initial Program Counter
000E     0348          Initial Stack Pointer
                       File "com.spi.spin"
0010     0308 0008     Link to Next Object
0014     029C 0000     Link to PUB Start(datapin, clockpin, inputmode, outputmode, delay, state) : okay
0018     02BE 0000     Link to PUB Send(bits, value)
001C     02CA 0000     Link to PUB Receive(bits)
0020     02D5 0000     Link to PUB Stop
0024     02E0 0000     Link to PRI ShiftOut(dpin, cpin, mode, bits, value)                     ''If SHIFTOUT is called with 'Bits' set to Zero, then the COG will shut
0028     02E6 0008     Link to PRI ShiftIn(dpin, cpin, mode, bits) | value, flag                  ''If SHIFTIN is called with 'Bits' set to Zero, then the COG will shut
002C     02F8 0000     Link to PRI SetCommand(cmd, argptr)
0030 000               DAT
0030 000                             org
0030 000 0ABD27F0      loop          rdlong  t1,par          wz                ''wait for command
0034 001 5C680000              if_z  jmp     #loop
0038 002 54FC0A9A                    movd    :arg,#arg0                        ''get 5 arguments ; arg0 to arg4
003C 003 A0BD2893                    mov     t2,t1                             ''    âÿ‚
0040 004 A0FD2A05                    mov     t3,#5                             ''ï‚ºâÿ€âÿ€âÿ€âÿÿ
0044 005 08BD3494      :arg          rdlong  arg0,t2
0048 006 80BC0A8A                    add     :arg,d0
004C 007 80FD2804                    add     t2,#4
0050 008 E4FD2A05                    djnz    t3,#:arg
0054 009 A0BD3293                    mov     address,t1                        ''preserve address location for passing
0058 00A 083D13F0                    wrlong  zero,par                          ''zero command to signify command received
005C 00B 20FD2612                    ror     t1,#16+2                          ''lookup command address
0060 00C 80FD2614                    add     t1,#jumps
0064 00D 50BC2093                    movs    :table,t1
0068 00E 24FD2602                    rol     t1,#2
006C 00F 2CFD2603                    shl     t1,#3
0070 010 A0BD2800      :table        mov     t2,0
0074 011 28BD2893                    shr     t2,t1
0078 012 60FD28FF                    and     t2,#$FF
007C 013 5C3C0094                    jmp     t2                                ''jump to command
0080 014 00            jumps         byte    0                                 ''0
0081     16                          byte    SHIFTOUT_                         ''1
0082     27                          byte    SHIFTIN_                          ''2
0083     15                          byte    NotUsed_                          ''3
0084 015 5C7C0000      NotUsed_      jmp     #loop
0088 016               SHIFTOUT_                                               ''SHIFTOUT Entry
0088 016 A2BD2C9D                    mov     t4,             arg3      wz      ''     Load number of data bits
008C 017 5C680083          if_z      jmp     #Done                             ''     '0' number of Bits = Done
0090 018 A2FD2601                    mov     t1,             #1        wz      ''     Configure DataPin
0094 019 2CBD269A                    shl     t1,             arg0
0098 01A 78BFE893                    muxz    outa,           t1                ''          PreSet DataPin LOW
009C 01B 7CBFEC93                    muxnz   dira,           t1                ''          Set DataPin to an OUTPUT
00A0 01C A2FD2801                    mov     t2,             #1        wz      ''     Configure ClockPin
00A4 01D 2CBD289B                    shl     t2,             arg1              ''          Set Mask
00A8 01E 617D2401                    test    clockstate,     #1        wc      ''          Determine Starting state
00AC 01F 788FE894          if_nc     muxz    outa,           t2                ''          PreSet ClockPin LOW
00B0 020 7CB3E894          if_c      muxnz   outa,           t2                ''          PreSet ClockPin HIGH
00B4 021 7CBFEC94                    muxnz   dira,           t2                ''          Set ClockPin to an OUTPUT
00B8 022 863D1E9C                    sub     _LSBFIRST,      arg2    wz,nr     ''     Detect LSBFIRST mode for SHIFTOUT
00BC 023 5C680057          if_z      jmp     #LSBFIRST_
00C0 024 863D209C                    sub     _MSBFIRST,      arg2    wz,nr     ''     Detect MSBFIRST mode for SHIFTOUT
00C4 025 5C680060          if_z      jmp     #MSBFIRST_
00C8 026 5C7C0000                    jmp     #loop                             ''     Go wait for next command
00CC 027               SHIFTIN_                                                ''SHIFTIN Entry
00CC 027 A2BD2C9D                    mov     t4,             arg3      wz      ''     Load number of data bits
00D0 028 5C680083          if_z      jmp     #Done                             ''     '0' number of Bits = Done
00D4 029 A2FD2601                    mov     t1,             #1        wz      ''     Configure DataPin
00D8 02A 2CBD269A                    shl     t1,             arg0
00DC 02B 78BFEC93                    muxz    dira,           t1                ''          Set DataPin to an INPUT
00E0 02C A2FD2801                    mov     t2,             #1        wz      ''     Configure ClockPin
00E4 02D 2CBD289B                    shl     t2,             arg1              ''          Set Mask
00E8 02E 617D2401                    test    clockstate,     #1        wc      ''          Determine Starting state
00EC 02F 788FE894          if_nc     muxz    outa,           t2                ''          PreSet ClockPin LOW
00F0 030 7CB3E894          if_c      muxnz   outa,           t2                ''          PreSet ClockPin HIGH
00F4 031 7CBFEC94                    muxnz   dira,           t2                ''          Set ClockPin to an OUTPUT
00F8 032 863D169C                    sub     _MSBPRE,        arg2    wz,nr     ''     Detect MSBPRE mode for SHIFTIN
00FC 033 5C68003B          if_z      jmp     #MSBPRE_
0100 034 863D189C                    sub     _LSBPRE,        arg2    wz,nr     ''     Detect LSBPRE mode for SHIFTIN
0104 035 5C680040          if_z      jmp     #LSBPRE_
0108 036 863D1A9C                    sub     _MSBPOST,       arg2    wz,nr     ''     Detect MSBPOST mode for SHIFTIN
010C 037 5C680049          if_z      jmp     #MSBPOST_
0110 038 863D1C9C                    sub     _LSBPOST,       arg2    wz,nr     ''     Detect LSBPOST mode for SHIFTIN
0114 039 5C68004E          if_z      jmp     #LSBPOST_
0118 03A 5C7C0000                    jmp     #loop                             ''     Go wait for next command
011C 03B               MSBPRE_                                                 ''     Receive Data MSBPRE
011C 03B 613D27F2      MSBPRE_Sin    test    t1,             ina     wc        ''          Read Data Bit into 'C' flag
0120 03C 34FD2A01                    rcl     t3,             #1                ''          rotate "C" flag into return value
0124 03D 5CFCF072                    call    #PreClock                         ''          Send clock pulse
0128 03E E4FD2C3B                    djnz    t4,             #MSBPRE_Sin       ''          Decrement t4 ; jump if not Zero
012C 03F 5C7C006C                    jmp     #Update_SHIFTIN                   ''     Pass received data to SHIFTIN receive variable
0130 040               LSBPRE_                                                 ''     Receive Data LSBPRE
0130 040 80FD2C01                    add     t4,             #1
0134 041 613D27F2      LSBPRE_Sin    test    t1,             ina       wc      ''          Read Data Bit into 'C' flag
0138 042 30FD2A01                    rcr     t3,             #1                ''          rotate "C" flag into return value
013C 043 5CFCF072                    call    #PreClock                         ''          Send clock pulse
0140 044 E4FD2C41                    djnz    t4,             #LSBPRE_Sin       ''     Decrement t4 ; jump if not Zero
0144 045 A0FD2C20                    mov     t4,             #32               ''     For LSB shift data right 32 - #Bits when done
0148 046 84BD2C9D                    sub     t4,             arg3
014C 047 28BD2A96                    shr     t3,             t4
0150 048 5C7C006C                    jmp     #Update_SHIFTIN                   ''     Pass received data to SHIFTIN receive variable
0154 049               MSBPOST_                                                ''     Receive Data MSBPOST
0154 049 5CFCFE79      MSBPOST_Sin   call    #PostClock                        ''          Send clock pulse
0158 04A 613D27F2                    test    t1,             ina     wc        ''          Read Data Bit into 'C' flag
015C 04B 34FD2A01                    rcl     t3,             #1                ''          rotate "C" flag into return value
0160 04C E4FD2C49                    djnz    t4,             #MSBPOST_Sin      ''          Decrement t4 ; jump if not Zero
0164 04D 5C7C006C                    jmp     #Update_SHIFTIN                   ''     Pass received data to SHIFTIN receive variable
0168 04E               LSBPOST_                                                ''     Receive Data LSBPOST
0168 04E 80FD2C01                    add     t4,             #1
016C 04F 5CFCFE79      LSBPOST_Sin   call    #PostClock                        ''          Send clock pulse
0170 050 613D27F2                    test    t1,             ina       wc      ''          Read Data Bit into 'C' flag
0174 051 30FD2A01                    rcr     t3,             #1                ''          rotate "C" flag into return value
0178 052 E4FD2C4F                    djnz    t4,             #LSBPOST_Sin      ''          Decrement t4 ; jump if not Zero
017C 053 A0FD2C20                    mov     t4,             #32               ''     For LSB shift data right 32 - #Bits when done
0180 054 84BD2C9D                    sub     t4,             arg3
0184 055 28BD2A96                    shr     t3,             t4
0188 056 5C7C006C                    jmp     #Update_SHIFTIN                   ''     Pass received data to SHIFTIN receive variable
018C 057               LSBFIRST_                                               ''     Send Data LSBFIRST
018C 057 A0BD2A9E                    mov     t3,             arg4              ''          Load t3 with DataValue
0190 058 617D2A01      LSB_Sout      test    t3,             #1      wc        ''          Test LSB of DataValue
0194 059 70BFE893                    muxc    outa,           t1                ''          Set DataBit HIGH or LOW
0198 05A 28FD2A01                    shr     t3,             #1                ''          Prepare for next DataBit
019C 05B 5CFCFE79                    call    #PostClock                        ''          Send clock pulse
01A0 05C E4FD2C58                    djnz    t4,             #LSB_Sout         ''          Decrement t4 ; jump if not Zero
01A4 05D A2FD2A00                    mov     t3,             #0      wz        ''          Force DataBit LOW
01A8 05E 7CBFE893                    muxnz   outa,           t1
01AC 05F 5C7C0000                    jmp     #loop                             ''     Go wait for next command
01B0 060               MSBFIRST_                                               ''     Send Data MSBFIRST
01B0 060 A0BD2A9E                    mov     t3,             arg4              ''          Load t3 with DataValue
01B4 061 A0FD2E01                    mov     t5,             #%1               ''          Create MSB mask     ;     load t5 with "1"
01B8 062 2CBD2E9D                    shl     t5,             arg3              ''          Shift "1" N number of bits to the left.
01BC 063 28FD2E01                    shr     t5,             #1                ''          Shifting the number of bits left actually puts
01C0 064 613D2A97      MSB_Sout      test    t3,             t5      wc        ''          Test MSB of DataValue
01C4 065 70BFE893                    muxc    outa,           t1                ''          Set DataBit HIGH or LOW
01C8 066 28FD2E01                    shr     t5,             #1                ''          Prepare for next DataBit
01CC 067 5CFCFE79                    call    #PostClock                        ''          Send clock pulse
01D0 068 E4FD2C64                    djnz    t4,             #MSB_Sout         ''          Decrement t4 ; jump if not Zero
01D4 069 A2FD2A00                    mov     t3,             #0      wz        ''          Force DataBit LOW
01D8 06A 7CBFE893                    muxnz   outa,           t1
01DC 06B 5C7C0000                    jmp     #loop                             ''     Go wait for next command
01E0 06C               Update_SHIFTIN
01E0 06C A0BD2699                    mov     t1,             address           ''     Write data back to Arg4
01E4 06D 80FD2610                    add     t1,             #16               ''          Arg0 = #0 ; Arg1 = #4 ; Arg2 = #8 ; Arg3 = #12 ; Arg4 = #16
01E8 06E 083D2A93                    wrlong  t3,             t1
01EC 06F 80FD2604                    add     t1,             #4                ''          Point t1 to Flag ... Arg4 + #4
01F0 070 083D1293                    wrlong  zero,           t1                ''          Clear Flag ... indicates SHIFTIN data is ready
01F4 071 5C7C0000                    jmp     #loop                             ''     Go wait for next command
01F8 072               PreClock
01F8 072 A07D2800                    mov     t2,             #0      nr        ''     Clock Pin
01FC 073 623D29F2                    test    t2,             ina     wz        ''          Read ClockPin
0200 074 78BFE894                    muxz    outa,           t2                ''          Set ClockPin to opposite  of read value
0204 075 5CFD0480                    call    #ClkDly
0208 076 7CBFE894                    muxnz   outa,           t2                ''          Restore ClockPin to original read value
020C 077 5CFD0480                    call    #ClkDly
0210 078 5C7C0000      PreClock_ret  ret                                       ''          return
0214 079               PostClock
0214 079 A07D2800                    mov     t2,             #0      nr        ''     Clock Pin
0218 07A 623D29F2                    test    t2,             ina     wz        ''          Read ClockPin
021C 07B 5CFD0480                    call    #ClkDly
0220 07C 78BFE894                    muxz    outa,           t2                ''          Set ClockPin to opposite  of read value
0224 07D 5CFD0480                    call    #ClkDly
0228 07E 7CBFE894                    muxnz   outa,           t2                ''          Restore ClockPin to original read value
022C 07F 5C7C0000      PostClock_ret ret                                       ''          return
0230 080               ClkDly
0230 080 A0BD3091                    mov       t6,     clockdelay
0234 081 E4FD3081      ClkPause      djnz      t6,     #ClkPause
0238 082 5C7C0000      ClkDly_ret    ret
023C 083               Done                                                    ''     Shut COG down
023C 083 A0FD2800                    mov     t2,             #0                ''          Preset temp variable to Zero
0240 084 A0BD27F0                    mov     t1,             par               ''          Read the address of the first perimeter
0244 085 80FD2604                    add     t1,             #4                ''          Add offset for the second perimeter ; The 'Flag' variable
0248 086 083D2893                    wrlong  t2,             t1                ''          Reset the 'Flag' variable to Zero
024C 087 0CFD2601                    CogID   t1                                ''          Read CogID
0250 088 0C7D2603                    COGSTOP t1                                ''          Stop this Cog!
0254 089 00000000      zero                    long    0                       ''constants
0258 08A 00000200      d0                      long    $200
025C 08B 00000000      _MSBPRE                 long    $0                      ''          Applies to SHIFTIN
0260 08C 00000001      _LSBPRE                 long    $1                      ''          Applies to SHIFTIN
0264 08D 00000002      _MSBPOST                long    $2                      ''          Applies to SHIFTIN
0268 08E 00000003      _LSBPOST                long    $3                      ''          Applies to SHIFTIN
026C 08F 00000004      _LSBFIRST               long    $4                      ''          Applies to SHIFTOUT
0270 090 00000005      _MSBFIRST               long    $5                      ''          Applies to SHIFTOUT
0274 091 00000000      clockdelay              long    0
0278 092 00000000      clockstate              long    0
027C 093 00000000      t1                      long    0                       ''     Used for DataPin mask     and     COG shutdown
0280 094 00000000      t2                      long    0                       ''     Used for CLockPin mask    and     COG shutdown
0284 095 00000000      t3                      long    0                       ''     Used to hold DataValue SHIFTIN/SHIFTOUT
0288 096 00000000      t4                      long    0                       ''     Used to hold # of Bits
028C 097 00000000      t5                      long    0                       ''     Used for temporary data mask
0290 098 00000000      t6                      long    0                       ''     Used for Clock delay
0294 099 00000000      address                 long    0                       ''     Used to hold return address of first Argument passed
0298 09A 00000000      arg0                    long    0                       ''arguments passed to/from high-level Spin
029C 09B 00000000      arg1                    long    0
02A0 09C 00000000      arg2                    long    0
02A4 09D 00000000      arg3                    long    0
02A8 09E 00000000      arg4                    long    0
02AC                   PUB Start(datapin, clockpin, inputmode, outputmode, delay, state) : okay
02AC                       Stop
02AC     01            ; Frame_Call_Noreturn
02AD     05 04         ; Call, $04
02AF                       _datapin    := datapin
02AF     64            ; Push_LocalMem_Long_1
02B0     89 08         ; Pop_VariableMem_Byte, $0008
02B2                       _clockpin   := clockpin
02B2     68            ; Push_LocalMem_Long_2
02B3     89 09         ; Pop_VariableMem_Byte, $0009
02B5                       _outputmode := outputmode
02B5     70            ; Push_LocalMem_Long_4
02B6     89 0B         ; Pop_VariableMem_Byte, $000B
02B8                       _inputmode  := inputmode
02B8     6C            ; Push_LocalMem_Long_3
02B9     89 0A         ; Pop_VariableMem_Byte, $000A
02BB                       clockdelay := delay
02BB     74            ; Push_LocalMem_Long_5
02BC     C5 82 64      ; Pop_ObjectMem_Long, $0264
02BF                       clockstate := state
02BF     78            ; Push_LocalMem_Long_6
02C0     C5 82 68      ; Pop_ObjectMem_Long, $0268
02C3                       okay := cog := cognew(@loop, @command) + 1
02C3     34            ; Push_Neg1
02C4     C7 20         ; Reference_ObjectMem_Long, $0020
02C6     47            ; Reference_VariableMem_Long_1
02C7     28            ; Coginit_Returns
02C8     36            ; Push_1
02C9     EC            ; Add
02CA     42 80         ; Effect_VariableMem_Long_0, write, push
02CC     61            ; Pop_LocalMem_Long_0
02CD     32            ; Return
02CE                   PUB Send(bits, value)
02CE                       ShiftOut(_datapin, _clockpin, _outputmode, bits, value)
02CE     01            ; Frame_Call_Noreturn
02CF     88 08         ; Push_VariableMem_Byte, $0008
02D1     88 09         ; Push_VariableMem_Byte, $0009
02D3     88 0B         ; Push_VariableMem_Byte, $000B
02D5     64            ; Push_LocalMem_Long_1
02D6     68            ; Push_LocalMem_Long_2
02D7     05 05         ; Call, $05
02D9     32            ; Return
02DA                   PUB Receive(bits)
02DA                       ShiftIn(_datapin, _clockpin, _inputmode, bits)
02DA     01            ; Frame_Call_Noreturn
02DB     88 08         ; Push_VariableMem_Byte, $0008
02DD     88 09         ; Push_VariableMem_Byte, $0009
02DF     88 0A         ; Push_VariableMem_Byte, $000A
02E1     64            ; Push_LocalMem_Long_1
02E2     05 06         ; Call, $06
02E4     32            ; Return
02E5                   PUB Stop
02E5                       if cog
02E5     40            ; Push_VariableMem_Long_0
02E6     0A 05         ; Jump_If_False, $0005
02E8                          cogStop(cog~ - 1)
02E8     42 98         ; Effect_VariableMem_Long_0, post-clear, push
02EA     36            ; Push_1
02EB     ED            ; Subtract
02EC     21            ; Cogstop
02ED                       command~
02ED     46 18         ; Effect_VariableMem_Long_1, post-clear
02EF     32            ; Return
02F0                   PRI ShiftOut(dpin, cpin, mode, bits, value)                     ''If SHIFTOUT is called with 'Bits' set to Zero, then the COG will shut
02F0                       SetCommand(_SHIFTOUT, @dpin)
02F0     01            ; Frame_Call_Noreturn
02F1     36            ; Push_1
02F2     67            ; Reference_LocalMem_Long_1
02F3     05 07         ; Call, $07
02F5     32            ; Return
02F6                   PRI ShiftIn(dpin, cpin, mode, bits) | value, flag                  ''If SHIFTIN is called with 'Bits' set to Zero, then the COG will shut
02F6                       flag := 1
02F6     36            ; Push_1
02F7     79            ; Pop_LocalMem_Long_6
02F8                       SetCommand(_SHIFTIN, @dpin)
02F8     01            ; Frame_Call_Noreturn
02F9     37 00         ; Push_Packed_Lit, $00000002
02FB     67            ; Reference_LocalMem_Long_1
02FC     05 07         ; Call, $07
02FE                       repeat until flag == 0
02FE     78            ; Push_LocalMem_Long_6
02FF     35            ; Push_0
0300     FC            ; Equal
0301     0B 02         ; Jump_If_True, $0002
0303     04 79         ; Branch, $FFF9
0305                       return value
0305     74            ; Push_LocalMem_Long_5
0306     33            ; Pop_Return
0307     32            ; Return
0308                   PRI SetCommand(cmd, argptr)
0308                       command := cmd << 16 + argptr                       ''write command and pointer
0308     64            ; Push_LocalMem_Long_1
0309     37 03         ; Push_Packed_Lit, $00000010
030B     E3            ; Shift_Left
030C     68            ; Push_LocalMem_Long_2
030D     EC            ; Add
030E     45            ; Pop_VariableMem_Long_1
030F                       repeat while command                                ''wait for command to be cleared, signifying receipt
030F     44            ; Push_VariableMem_Long_1
0310     0A 02         ; Jump_If_False, $0002
0312     04 7B         ; Branch, $FFFB
0314     32            ; Return
0315     00            ; Frame_Call_Return
0316     00            ; Frame_Call_Return
0317     00            ; Frame_Call_Return
                       Variables for TOP (com.spi.spin)
0318     0000          long COG
031C     0004          long COMMAND
0320     0008          byte _DATAPIN
0321     0009          byte _CLOCKPIN
0322     000A          byte _INPUTMODE
0323     000B          byte _OUTPUTMODE
0324                   Reserved 8 bytes.
032C                   Base of stack.
033C                   Top of stack.

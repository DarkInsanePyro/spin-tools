0000     00B71B00      Frequency 12000000 Hz
0004     00            RCFast
0005     B2            Check Sum
0006     0010          Base of Program
0008     0210          Base of Variables
000A     025C          Base of Stack
000C     0044          Initial Program Counter
000E     0264          Initial Stack Pointer
                       File "string.integer.spin"
0010     0200 000D     Link to Next Object
0014     0034 0000     Link to PUB Dec(value)
0018     0041 0008     Link to PUB DecPadded(value, width) | t_val, field
001C     0083 0004     Link to PUB DecZeroed(value, digits) | div
0020     00D6 0000     Link to PUB Hex(value, digits)
0024     00E4 0000     Link to PUB HexIndicated(value, digits)
0028     00F8 0000     Link to PUB Bin(value, digits)
002C     0106 0000     Link to PUB BinIndicated(value, digits)
0030     011A 0008     Link to PUB StrToBase(stringptr, base) : value | chr, index
0034     015B 0000     Link to PRI ClearStr(strAddr, size)
0038     0162 0008     Link to PRI DecToStr(value) | div, z_pad
003C     01A8 0000     Link to PRI HexToStr(value, digits)
0040     01DB 0000     Link to PRI BinToStr(value, digits)
0044                   PUB Dec(value)
0044                       ClearStr(@nstr, MAX_LEN)                                ' clear output string
0044     01            ; Frame_Call_Noreturn
0045     8B 04         ; Reference_VariableMem_Byte, $0004
0047     37 05         ; Push_Packed_Lit, $00000040
0049     05 09         ; Call, $09
004B                       return DecToStr(value)                                  ' return pointer to numeric string
004B     00            ; Frame_Call_Return
004C     64            ; Push_LocalMem_Long_1
004D     05 0A         ; Call, $0A
004F     33            ; Pop_Return
0050     32            ; Return
0051                   PUB DecPadded(value, width) | t_val, field
0051                       ClearStr(@nstr, MAX_LEN)
0051     01            ; Frame_Call_Noreturn
0052     8B 04         ; Reference_VariableMem_Byte, $0004
0054     37 05         ; Push_Packed_Lit, $00000040
0056     05 09         ; Call, $09
0058                       width := 1 #> width <# constant(MAX_LEN - 1)          ' qualify field width
0058     36            ; Push_1
0059     68            ; Push_LocalMem_Long_2
005A     E4            ; Limit_Min
005B     37 25         ; Push_Packed_Lit, $0000003F
005D     E5            ; Limit_Max
005E     69            ; Pop_LocalMem_Long_2
005F                       t_val := ||value                                      ' work with absolute
005F     64            ; Push_LocalMem_Long_1
0060     E9            ; Absolute_Value
0061     6D            ; Pop_LocalMem_Long_3
0062                       field~                                                ' clear field
0062     72 18         ; Effect_LocalMem_Long_4, post-clear
0064                       repeat while t_val > 0                                ' count number of digits
0064     6C            ; Push_LocalMem_Long_3
0065     35            ; Push_0
0066     FA            ; Greater
0067     0A 08         ; Jump_If_False, $0008
0069                           field++
0069     72 2E         ; Effect_LocalMem_Long_4, post-inc, long
006B                           t_val /= 10
006B     38 0A         ; Push_Byte_Lit, $0A
006D     6E 56         ; Effect_LocalMem_Long_3, Divide, swap
006F     04 73         ; Branch, $FFF3
0071                       field #>= 1                                           ' min field width is 1
0071     36            ; Push_1
0072     72 44         ; Effect_LocalMem_Long_4, Limit_Min, swap
0074                       if value < 0                                          ' if value is negative
0074     64            ; Push_LocalMem_Long_1
0075     35            ; Push_0
0076     F9            ; Less
0077     0A 02         ; Jump_If_False, $0002
0079                           field++                                             '   bump field for neg sign indicator
0079     72 2E         ; Effect_LocalMem_Long_4, post-inc, long
007B                       if field < width                                      ' need padding?
007B     70            ; Push_LocalMem_Long_4
007C     68            ; Push_LocalMem_Long_2
007D     F9            ; Less
007E     0A 0D         ; Jump_If_False, $000D
0080                           repeat (width - field)                              ' yes
0080     68            ; Push_LocalMem_Long_2
0081     70            ; Push_LocalMem_Long_4
0082     ED            ; Subtract
0083     08 08         ; Loop_Start, $0008
0085                               nstr[idx++] := " "                                '   pad with space(s)
0085     37 04         ; Push_Packed_Lit, $00000020
0087     42 AE         ; Effect_VariableMem_Long_0, post-inc, long
0089     99 04         ; Pop_Indexed_VariableMem_Byte, $0004
008B     09 78         ; Loop_Continue, $FFF8
008D                       return DecToStr(value)
008D     00            ; Frame_Call_Return
008E     64            ; Push_LocalMem_Long_1
008F     05 0A         ; Call, $0A
0091     33            ; Pop_Return
0092     32            ; Return
0093                   PUB DecZeroed(value, digits) | div
0093                       ClearStr(@nstr, MAX_LEN)
0093     01            ; Frame_Call_Noreturn
0094     8B 04         ; Reference_VariableMem_Byte, $0004
0096     37 05         ; Push_Packed_Lit, $00000040
0098     05 09         ; Call, $09
009A                       digits := 1 #> digits <# 10
009A     36            ; Push_1
009B     68            ; Push_LocalMem_Long_2
009C     E4            ; Limit_Min
009D     38 0A         ; Push_Byte_Lit, $0A
009F     E5            ; Limit_Max
00A0     69            ; Pop_LocalMem_Long_2
00A1                       if (value < 0)                                        ' negative value?
00A1     64            ; Push_LocalMem_Long_1
00A2     35            ; Push_0
00A3     F9            ; Less
00A4     0A 08         ; Jump_If_False, $0008
00A6                           -value                                              '   yes, make positive
00A6     66 46         ; Effect_LocalMem_Long_1, Negate, swap
00A8                           nstr[idx++] := "-"                                  '   and print sign indicator
00A8     38 2D         ; Push_Byte_Lit, $2D
00AA     42 AE         ; Effect_VariableMem_Long_0, post-inc, long
00AC     99 04         ; Pop_Indexed_VariableMem_Byte, $0004
00AE                       div := 1_000_000_000                                  ' initialize divisor
00AE     3B 3B9ACA00   ; Push_Long_Lit, $3B9ACA00
00B3     6D            ; Pop_LocalMem_Long_3
00B4                       if digits < 10                                        ' less than 10 digits?
00B4     68            ; Push_LocalMem_Long_2
00B5     38 0A         ; Push_Byte_Lit, $0A
00B7     F9            ; Less
00B8     0A 0C         ; Jump_If_False, $000C
00BA                           repeat (10 - digits)                                '   yes, adjust divisor
00BA     38 0A         ; Push_Byte_Lit, $0A
00BC     68            ; Push_LocalMem_Long_2
00BD     ED            ; Subtract
00BE     08 06         ; Loop_Start, $0006
00C0                               div /= 10
00C0     38 0A         ; Push_Byte_Lit, $0A
00C2     6E 56         ; Effect_LocalMem_Long_3, Divide, swap
00C4     09 7A         ; Loop_Continue, $FFFA
00C6                       value //= (div * 10)                                  ' truncate unused digits
00C6     6C            ; Push_LocalMem_Long_3
00C7     38 0A         ; Push_Byte_Lit, $0A
00C9     F4            ; Multiply
00CA     66 57         ; Effect_LocalMem_Long_1, Modulo, swap
00CC                       repeat digits
00CC     68            ; Push_LocalMem_Long_2
00CD     08 13         ; Loop_Start, $0013
00CF                           nstr[idx++] := (value / div + "0")                  ' convert digit to ASCII
00CF     64            ; Push_LocalMem_Long_1
00D0     6C            ; Push_LocalMem_Long_3
00D1     F6            ; Divide
00D2     38 30         ; Push_Byte_Lit, $30
00D4     EC            ; Add
00D5     42 AE         ; Effect_VariableMem_Long_0, post-inc, long
00D7     99 04         ; Pop_Indexed_VariableMem_Byte, $0004
00D9                           value //= div                                       ' update value
00D9     6C            ; Push_LocalMem_Long_3
00DA     66 57         ; Effect_LocalMem_Long_1, Modulo, swap
00DC                           div /= 10                                           ' update divisor
00DC     38 0A         ; Push_Byte_Lit, $0A
00DE     6E 56         ; Effect_LocalMem_Long_3, Divide, swap
00E0     09 6D         ; Loop_Continue, $FFED
00E2                       return @nstr
00E2     8B 04         ; Reference_VariableMem_Byte, $0004
00E4     33            ; Pop_Return
00E5     32            ; Return
00E6                   PUB Hex(value, digits)
00E6                       ClearStr(@nstr, MAX_LEN)
00E6     01            ; Frame_Call_Noreturn
00E7     8B 04         ; Reference_VariableMem_Byte, $0004
00E9     37 05         ; Push_Packed_Lit, $00000040
00EB     05 09         ; Call, $09
00ED                       return HexToStr(value, digits)
00ED     00            ; Frame_Call_Return
00EE     64            ; Push_LocalMem_Long_1
00EF     68            ; Push_LocalMem_Long_2
00F0     05 0B         ; Call, $0B
00F2     33            ; Pop_Return
00F3     32            ; Return
00F4                   PUB HexIndicated(value, digits)
00F4                       ClearStr(@nstr, MAX_LEN)
00F4     01            ; Frame_Call_Noreturn
00F5     8B 04         ; Reference_VariableMem_Byte, $0004
00F7     37 05         ; Push_Packed_Lit, $00000040
00F9     05 09         ; Call, $09
00FB                       nstr[idx++] := "$"
00FB     38 24         ; Push_Byte_Lit, $24
00FD     42 AE         ; Effect_VariableMem_Long_0, post-inc, long
00FF     99 04         ; Pop_Indexed_VariableMem_Byte, $0004
0101                       return HexToStr(value, digits)
0101     00            ; Frame_Call_Return
0102     64            ; Push_LocalMem_Long_1
0103     68            ; Push_LocalMem_Long_2
0104     05 0B         ; Call, $0B
0106     33            ; Pop_Return
0107     32            ; Return
0108                   PUB Bin(value, digits)
0108                       ClearStr(@nstr, MAX_LEN)
0108     01            ; Frame_Call_Noreturn
0109     8B 04         ; Reference_VariableMem_Byte, $0004
010B     37 05         ; Push_Packed_Lit, $00000040
010D     05 09         ; Call, $09
010F                       return BinToStr(value, digits)
010F     00            ; Frame_Call_Return
0110     64            ; Push_LocalMem_Long_1
0111     68            ; Push_LocalMem_Long_2
0112     05 0C         ; Call, $0C
0114     33            ; Pop_Return
0115     32            ; Return
0116                   PUB BinIndicated(value, digits)
0116                       ClearStr(@nstr, MAX_LEN)
0116     01            ; Frame_Call_Noreturn
0117     8B 04         ; Reference_VariableMem_Byte, $0004
0119     37 05         ; Push_Packed_Lit, $00000040
011B     05 09         ; Call, $09
011D                       nstr[idx++] := "%"                                    ' preface with binary indicator
011D     38 25         ; Push_Byte_Lit, $25
011F     42 AE         ; Effect_VariableMem_Long_0, post-inc, long
0121     99 04         ; Pop_Indexed_VariableMem_Byte, $0004
0123                       return BinToStr(value, digits)
0123     00            ; Frame_Call_Return
0124     64            ; Push_LocalMem_Long_1
0125     68            ; Push_LocalMem_Long_2
0126     05 0C         ; Call, $0C
0128     33            ; Pop_Return
0129     32            ; Return
012A                   PUB StrToBase(stringptr, base) : value | chr, index
012A                       value := index := 0
012A     35            ; Push_0
012B     72 80         ; Effect_LocalMem_Long_4, write, push
012D     61            ; Pop_LocalMem_Long_0
012E                       repeat until ((chr := byte[stringptr][index++]) == 0)
012E     64            ; Push_LocalMem_Long_1
012F     72 AE         ; Effect_LocalMem_Long_4, post-inc, long
0131     90            ; Push_Indexed_MainMem_Byte
0132     6E 80         ; Effect_LocalMem_Long_3, write, push
0134     35            ; Push_0
0135     FC            ; Equal
0136     0B 23         ; Jump_If_True, $0023
0138                           chr := -15 + --chr & %11011111 + 39*(chr > 56)                      ' Make "0"-"9","A"-"F","a"-"f" be 0 - 15, others out of range
0138     38 0E         ; Push_Byte_Lit, $0E
013A     E7            ; Complement
013B     6E B6         ; Effect_LocalMem_Long_3, pre-dec, long
013D     38 DF         ; Push_Byte_Lit, $DF
013F     E8            ; Bit_And
0140     EC            ; Add
0141     38 27         ; Push_Byte_Lit, $27
0143     6C            ; Push_LocalMem_Long_3
0144     38 38         ; Push_Byte_Lit, $38
0146     FA            ; Greater
0147     F4            ; Multiply
0148     EC            ; Add
0149     6D            ; Pop_LocalMem_Long_3
014A                           if (chr > -1) and (chr < base)                                      ' Accumulate valid values into result; ignore others
014A     6C            ; Push_LocalMem_Long_3
014B     34            ; Push_Neg1
014C     FA            ; Greater
014D     6C            ; Push_LocalMem_Long_3
014E     68            ; Push_LocalMem_Long_2
014F     F9            ; Less
0150     F0            ; Logical_And
0151     0A 06         ; Jump_If_False, $0006
0153                               value := value * base + chr
0153     60            ; Push_LocalMem_Long_0
0154     68            ; Push_LocalMem_Long_2
0155     F4            ; Multiply
0156     6C            ; Push_LocalMem_Long_3
0157     EC            ; Add
0158     61            ; Pop_LocalMem_Long_0
0159     04 53         ; Branch, $FFD3
015B                       if (base == 10) and (byte[stringptr] == "-")                            ' If decimal, address negative sign; ignore otherwise
015B     68            ; Push_LocalMem_Long_2
015C     38 0A         ; Push_Byte_Lit, $0A
015E     FC            ; Equal
015F     64            ; Push_LocalMem_Long_1
0160     80            ; Push_MainMem_Byte
0161     38 2D         ; Push_Byte_Lit, $2D
0163     FC            ; Equal
0164     F0            ; Logical_And
0165     0A 03         ; Jump_If_False, $0003
0167                           value := - value
0167     60            ; Push_LocalMem_Long_0
0168     E6            ; Negate
0169     61            ; Pop_LocalMem_Long_0
016A     32            ; Return
016B                   PRI ClearStr(strAddr, size)
016B                       bytefill(strAddr, 0, size)                            ' clear string to zeros
016B     64            ; Push_LocalMem_Long_1
016C     35            ; Push_0
016D     68            ; Push_LocalMem_Long_2
016E     18            ; Bytefill
016F                       idx~                                                  ' reset index
016F     42 18         ; Effect_VariableMem_Long_0, post-clear
0171     32            ; Return
0172                   PRI DecToStr(value) | div, z_pad
0172                       if (value < 0)                                        ' negative value?
0172     64            ; Push_LocalMem_Long_1
0173     35            ; Push_0
0174     F9            ; Less
0175     0A 08         ; Jump_If_False, $0008
0177                           -value                                              '   yes, make positive
0177     66 46         ; Effect_LocalMem_Long_1, Negate, swap
0179                           nstr[idx++] := "-"                                  '   and print sign indicator
0179     38 2D         ; Push_Byte_Lit, $2D
017B     42 AE         ; Effect_VariableMem_Long_0, post-inc, long
017D     99 04         ; Pop_Indexed_VariableMem_Byte, $0004
017F                       div := 1_000_000_000                                  ' initialize divisor
017F     3B 3B9ACA00   ; Push_Long_Lit, $3B9ACA00
0184     69            ; Pop_LocalMem_Long_2
0185                       z_pad~                                                ' clear zero-pad flag
0185     6E 18         ; Effect_LocalMem_Long_3, post-clear
0187                       repeat 10
0187     38 0A         ; Push_Byte_Lit, $0A
0189     08 29         ; Loop_Start, $0029
018B                           if (value => div)                                   ' printable character?
018B     64            ; Push_LocalMem_Long_1
018C     68            ; Push_LocalMem_Long_2
018D     FE            ; Greater_Equal
018E     0A 11         ; Jump_If_False, $0011
0190                               nstr[idx++] := (value / div + "0")                '   yes, print ASCII digit
0190     64            ; Push_LocalMem_Long_1
0191     68            ; Push_LocalMem_Long_2
0192     F6            ; Divide
0193     38 30         ; Push_Byte_Lit, $30
0195     EC            ; Add
0196     42 AE         ; Effect_VariableMem_Long_0, post-inc, long
0198     99 04         ; Pop_Indexed_VariableMem_Byte, $0004
019A                               value //= div                                     '   update value
019A     68            ; Push_LocalMem_Long_2
019B     66 57         ; Effect_LocalMem_Long_1, Modulo, swap
019D                               z_pad~~                                           '   set zflag
019D     6E 1C         ; Effect_LocalMem_Long_3, post-set
019F     04 0D         ; Branch, $000D
01A1     6C            ; Push_LocalMem_Long_3
01A2     68            ; Push_LocalMem_Long_2
01A3     36            ; Push_1
01A4     FC            ; Equal
01A5     F2            ; Logical_Or
01A6     0A 06         ; Jump_If_False, $0006
01A8                               nstr[idx++] := "0"
01A8     38 30         ; Push_Byte_Lit, $30
01AA     42 AE         ; Effect_VariableMem_Long_0, post-inc, long
01AC     99 04         ; Pop_Indexed_VariableMem_Byte, $0004
01AE                           div /= 10
01AE     38 0A         ; Push_Byte_Lit, $0A
01B0     6A 56         ; Effect_LocalMem_Long_2, Divide, swap
01B2     09 57         ; Loop_Continue, $FFD7
01B4                       return @nstr
01B4     8B 04         ; Reference_VariableMem_Byte, $0004
01B6     33            ; Pop_Return
01B7     32            ; Return
01B8                   PRI HexToStr(value, digits)
01B8                       digits := 1 #> digits <# 8                            ' qualify digits
01B8     36            ; Push_1
01B9     68            ; Push_LocalMem_Long_2
01BA     E4            ; Limit_Min
01BB     37 02         ; Push_Packed_Lit, $00000008
01BD     E5            ; Limit_Max
01BE     69            ; Pop_LocalMem_Long_2
01BF                       value <<= (8 - digits) << 2                           ' prep most significant digit
01BF     37 02         ; Push_Packed_Lit, $00000008
01C1     68            ; Push_LocalMem_Long_2
01C2     ED            ; Subtract
01C3     37 00         ; Push_Packed_Lit, $00000002
01C5     E3            ; Shift_Left
01C6     66 43         ; Effect_LocalMem_Long_1, Shift_Left, swap
01C8                       repeat digits
01C8     68            ; Push_LocalMem_Long_2
01C9     08 1C         ; Loop_Start, $001C
01CB                           nstr[idx++] := lookupz((value <-= 4) & $F : "0".."9", "A".."F")
01CB     35            ; Push_0
01CC     39 01D1       ; Push_Word_Lit, $01D1
01CF     37 01         ; Push_Packed_Lit, $00000004
01D1     66 C1         ; Effect_LocalMem_Long_1, Rotate_Left, swap
01D3     37 23         ; Push_Packed_Lit, $0000000F
01D5     E8            ; Bit_And
01D6     38 30         ; Push_Byte_Lit, $30
01D8     38 39         ; Push_Byte_Lit, $39
01DA     12            ; Lookuprange_Compare
01DB     38 41         ; Push_Byte_Lit, $41
01DD     38 46         ; Push_Byte_Lit, $46
01DF     12            ; Lookuprange_Compare
01E0     0F            ; Look_Abort
01E1     42 AE         ; Effect_VariableMem_Long_0, post-inc, long
01E3     99 04         ; Pop_Indexed_VariableMem_Byte, $0004
01E5     09 64         ; Loop_Continue, $FFE4
01E7                       return @nstr
01E7     8B 04         ; Reference_VariableMem_Byte, $0004
01E9     33            ; Pop_Return
01EA     32            ; Return
01EB                   PRI BinToStr(value, digits)
01EB                       digits := 1 #> digits <# 32                           ' qualify digits
01EB     36            ; Push_1
01EC     68            ; Push_LocalMem_Long_2
01ED     E4            ; Limit_Min
01EE     37 04         ; Push_Packed_Lit, $00000020
01F0     E5            ; Limit_Max
01F1     69            ; Pop_LocalMem_Long_2
01F2                       value <<= 32 - digits                                 ' prep MSB
01F2     37 04         ; Push_Packed_Lit, $00000020
01F4     68            ; Push_LocalMem_Long_2
01F5     ED            ; Subtract
01F6     66 43         ; Effect_LocalMem_Long_1, Shift_Left, swap
01F8                       repeat digits
01F8     68            ; Push_LocalMem_Long_2
01F9     08 0E         ; Loop_Start, $000E
01FB                           nstr[idx++] := (value <-= 1) & 1 + "0"              ' move digits (ASCII) to string
01FB     36            ; Push_1
01FC     66 C1         ; Effect_LocalMem_Long_1, Rotate_Left, swap
01FE     36            ; Push_1
01FF     E8            ; Bit_And
0200     38 30         ; Push_Byte_Lit, $30
0202     EC            ; Add
0203     42 AE         ; Effect_VariableMem_Long_0, post-inc, long
0205     99 04         ; Pop_Indexed_VariableMem_Byte, $0004
0207     09 72         ; Loop_Continue, $FFF2
0209                       return @nstr
0209     8B 04         ; Reference_VariableMem_Byte, $0004
020B     33            ; Pop_Return
020C     32            ; Return
020D     00            ; Frame_Call_Return
020E     00            ; Frame_Call_Return
020F     00            ; Frame_Call_Return
                       Variables for TOP (string.integer.spin)
0210     0000          long IDX
0214     0004          byte NSTR[64]
0254                   Reserved 8 bytes.
025C                   Base of stack.
026C                   Top of stack.

0000     00B71B00      Frequency 12000000 Hz
0004     00            RCFast
0005     E1            Check Sum
0006     0010          Base of Program
0008     0A38          Base of Variables
000A     0A48          Base of Stack
000C     0878          Initial Program Counter
000E     0A4C          Initial Stack Pointer
                       File "math.float.spin"
0010     0A28 002A     Link to Next Object
0014     0868 0000     Link to PUB Start
0018     087A 0000     Link to PUB Stop
001C     0885 0000     Link to PUB FloatF(a)
0020     088F 0000     Link to PUB RoundF(a)
0024     089A 0000     Link to PUB TruncF(a)
0028     08A5 0000     Link to PUB TruncUInt(a)
002C     08AF 0000     Link to PUB TruncFInt(a)
0030     08B9 0000     Link to PUB RoundFInt(a)
0034     08C3 0000     Link to PUB NegF(a)
0038     08C9 0000     Link to PUB AbsF(a)
003C     08CF 0000     Link to PUB AddF(a, b)
0040     08D9 0000     Link to PUB SubF(a, b)
0044     08E3 0000     Link to PUB MulF(a, b)
0048     08ED 0000     Link to PUB DivF(a, b)
004C     08F7 0000     Link to PUB ModF(a, b)
0050     0901 0000     Link to PUB CmpF(a, b)
0054     090B 0000     Link to PUB Sqrt(a)
0058     0915 0000     Link to PUB Sin(a)
005C     091F 0000     Link to PUB Cos(a)
0060     0929 0000     Link to PUB Tan(a)
0064     0933 0000     Link to PUB Log(a)
0068     0941 0000     Link to PUB Log2(a)
006C     094B 0000     Link to PUB Log10(a)
0070     0959 0000     Link to PUB Exp(a)
0074     0967 0000     Link to PUB Exp2(a)
0078     0971 0000     Link to PUB Exp10(a)
007C     097F 0000     Link to PUB Pow(a, b)
0080     0989 0000     Link to PUB Frac(a)
0084     0993 0000     Link to PUB Rad(a)
0088     09A1 0000     Link to PUB Deg(a)
008C     09AF 0000     Link to PUB ArcSin(a)
0090     09B9 0000     Link to PUB ArcCos(a)
0094     09C3 0000     Link to PUB ArcTan(a)
0098     09D1 0000     Link to PUB ArcTan2(a, b)
009C     09DB 0000     Link to PUB Floor(a)
00A0     09E5 0000     Link to PUB Ceil(a)
00A4     09EF 0000     Link to PUB Minimum(a, b)
00A8     0A02 0000     Link to PUB Maximum(a, b)
00AC     0A15 0000     Link to PUB Cmd_ptr
00B0     0A18 0000     Link to PUB Call_ptr
00B4     0A1D 0000     Link to PRI SetCommand(a, b, cmd)
00B8 000               DAT
00B8 000                                       org     0                       ' (try to keep 2 or fewer instructions between rd/wrlong)
00B8 000 0ABFB7F0      f32_entry               rdlong  ret_ptr, par wz         ' wait for command to be non-zero, and store it in the call location
00BC 001 5C680000                    if_z      jmp     #f32_entry
00C0 002 08BC11DB                              rdlong  :execCmd, ret_ptr       ' get the pointer to the return value ("@result")
00C4 003 80FFB604                              add     ret_ptr, #4
00C8 004 08BFC7DB                              rdlong  fnumA, ret_ptr          ' fnumA is the long after "result"
00CC 005 80FFB604                              add     ret_ptr, #4
00D0 006 08BFCFDB                              rdlong  fnumB, ret_ptr          ' fnumB is the long after fnumA
00D4 007 84FFB608                              sub     ret_ptr, #8
00D8 008               :execCmd                nop                             ' execute command, which was replaced by getCommand
00D8 008 00 00 00 00
00DC 009 083FC7DB      :finishCmd              wrlong  fnumA, ret_ptr          ' store the result (2 longs before fnumB)
00E0 00A 083FEBF0                              wrlong  outb, par               ' clear command status (outb is initialized to 0)
00E4 00B 5C7C0000                              jmp     #f32_entry              ' wait for next command
00E8 00C 6CBFCFD7      _FSub                   xor     fnumB, Bit31            ' negate B
00EC 00D 5CFE5921      _FAdd                   call    #_Unpack2               ' unpack two variables
00F0 00E 5C38001E                if_c_or_z     jmp     _FAdd_ret              ' check for NaN or B = 0
00F4 00F 627FC801                              test    flagA, #SignFlag wz     ' negate A mantissa if negative
00F8 010 A497CDE6                if_nz         neg     manA, manA
00FC 011 627FD001                              test    flagB, #SignFlag wz     ' negate B mantissa if negative
0100 012 A497D5EA                if_nz         neg     manB, manB
0104 013 A0BFB9E5                              mov     t1, expA                ' align mantissas
0108 014 84BFB9E9                              sub     t1, expB
010C 015 A9BFB9DC                              abs     t1, t1          wc
0110 016 4CFFB81F                              max     t1, #31
0114 017 388FD5DC                    if_nc     sar     manB, t1
0118 018 38B3CDDC                    if_c      sar     manA, t1
011C 019 A0B3CBE9                    if_c      mov     expA, expB
0120 01A 80BFCDEA                              add     manA, manB              ' add the two mantissas
0124 01B A9BFCDE6                              abs     manA, manA      wc      ' store the absolte value,
0128 01C 70FFC801                              muxc    flagA, #SignFlag        ' and flag if it was negative
012C 01D 5CFEC14B                              call    #_Pack                  ' pack result and exit
0130 01E               _FSub_ret
0130 01E 5C7C0000      _FAdd_ret               ret
0134 01F 5CFE5921      _FMul                   call    #_Unpack2               ' unpack two variables
0138 020 5C300032                    if_c      jmp     _FMul_ret              ' check for NaN
013C 021 6CBFC9E8                              xor     flagA, flagB            ' get sign of result
0140 022 80BFCBE9                              add     expA, expB              ' add exponents
0144 023 A4BFB9E6                              neg     t1, manA                ' isolate the low bit of manA
0148 024 60BFB9E6                              and     t1, manA
014C 025 A4BFBBEA                              neg     t2, manB                ' isolate the low bit of manB
0150 026 60BFBBEA                              and     t2, manB
0154 027 853FB9DD                              cmp     t1, t2 wc               ' who has the greater low bit?  After reversal, this will go to 0 faster.
0158 028 A2B3B9E6                    if_c      mov     t1, manA wz             ' if t1 is 0, we'll just skip through everything              '
015C 029 A28FB9EA                    if_nc     mov     t1, manB wz             ' ditto, only t1 is manB
0160 02A A08FD5E6                    if_nc     mov     manB, manA              ' and in this case we wanted manA to be the multiplier mask
0164 02B A0FFCC00                              mov     manA, #0                ' manA is my new accumulator
0168 02C 3CFFD402                              rev     manB, #32-30            ' start by right aligning the reverse of the B mantissa
016C 02D 2BD7D401      :multiply     if_nz     shr     manB, #1 wc,wz          ' get multiplier bit, and take note if we hit 0 (skip if t1 was already 0!)
0170 02E 80B3CDDC                    if_c      add     manA, t1                ' if the bit was set, add in the multiplicand
0174 02F 28FFB801                              shr     t1, #1                  ' adjust my increment value's bit alignment
0178 030 5C54002D                    if_nz     jmp     #:multiply              ' go back for more
017C 031 5CFEC14B                              call    #_Pack
0180 032 5C7C0000      _FMul_ret               ret
0184 033 5CFE5921      _FDiv                   call    #_Unpack2               ' unpack two variables
0188 034 A0BBC7CF                if_c_or_z     mov     fnumA, NaN              ' check for NaN or divide by 0
018C 035 5C380041                if_c_or_z     jmp     _FDiv_ret
0190 036 6CBFC9E8                              xor     flagA, flagB            ' get sign of result
0194 037 84BFCBE9                              sub     expA, expB              ' subtract exponents
0198 038 A0FFB800                              mov     t1, #0                  ' clear quotient
019C 039 A0FFBA1A                              mov     t2, #26                 ' loop counter for divide (need 24, plus 2 for rounding)
01A0 03A               :divide                 ' divide the mantissas
01A0 03A E1BFCDEA                              cmpsub  manA, manB      wc
01A4 03B 34FFB801                              rcl     t1, #1
01A8 03C 2CFFCC01                              shl     manA, #1
01AC 03D E4FFBA3A                              djnz    t2, #:divide
01B0 03E 2CFFB804                              shl     t1, #4                  ' align the result (we did 26 instead of 30 iterations)
01B4 03F A0BFCDDC                              mov     manA, t1                ' get result and exit
01B8 040 5CFEC14B                              call    #_Pack
01BC 041 5C7C0000      _FDiv_ret               ret
01C0 042 ABBFCDE3      _FFloat                 abs     manA, fnumA     wc,wz   ' get |integer value|
01C4 043 5C280047                    if_z      jmp     _FFloat_ret            ' if zero, exit
01C8 044 70FFC801                              muxc    flagA, #SignFlag        ' depending on the integer's sign
01CC 045 A0FFCA1D                              mov     expA, #29               ' set my exponent
01D0 046 5CFEC14B                              call    #_Pack                  ' pack and exit
01D4 047 5C7C0000      _FFloat_ret             ret
01D8 048 A0BFB9E3      _FTruncRound            mov     t1, fnumA               ' grab a copy of the input
01DC 049 5CFE952D                              call    #_Unpack                ' unpack floating point value
01E0 04A E1FFCE02                              cmpsub  fnumB, #%10     wc      ' clear bit 1 and set the C flag if it was a 1
01E4 04B 34FFBA01                              rcl     t2, #1
01E8 04C 62FFBA01                              and     t2, #1          wz      ' Z now signified integer output
01EC 04D 2CFFCC02                              shl     manA, #2                ' left justify mantissa
01F0 04E 84FFCA1E                              sub     expA, #30               ' our target exponent is 30
01F4 04F A9BFCBE5                              abs     expA, expA      wc      ' adjust for exponent sign, and track if it was negative
01F8 050 A08BCDCF                    if_z_and_nc mov   manA, NaN               ' integer output, and it's too large for us to handle
01FC 051 5C48005D                    if_z_and_nc jmp   #:check_sign
0200 052 A087C7DC                    if_nz_and_nc mov  fnumA, t1                ' float output, and we're already all integer
0204 053 5C04005F                    if_nz_and_nc jmp  _FTruncRound_ret
0208 054 857FCA20                              cmp     expA, #32       wc      ' DO set the C flag here...I want to know if expA =< 31, aka < 32
020C 055 4CFFCA1F                              max     expA, #31               ' DON'T set the C flag here...max sets C if D<S
0210 056 28BFCDE5                              shr     manA, expA
0214 057 80B3CDE7                    if_c      add     manA, fnumB             ' round up 1/2 lsb if desired, and if it isn't supposed to be 0! (if expA was > 31)
0218 058 28FFCC01                              shr     manA, #1
021C 059 5C68005D                    if_z      jmp     #:check_sign            ' integer output?
0220 05A A0FFCA1D                              mov     expA, #29
0224 05B 5CFEC14B                              call    #_Pack
0228 05C 5C3C005F                              jmp     _FTruncRound_ret
022C 05D 627FC801      :check_sign             test    flagA, #SignFlag wz     ' check sign and exit
0230 05E BCBFC7E6                              negnz   fnumA, manA
0234 05F 5C7C0000      _FTruncRound_ret        ret
0238 060 5CFE952D      _UintTrunc              call    #_Unpack
023C 061 A0FFC600                              mov     fnumA, #0
0240 062 617FC801                              test    flagA, #SignFlag wc
0244 063 5C38006B                    if_c_or_z jmp     _UintTrunc_ret         ' if the input number was negative or zero, we're done
0248 064 2CFFCC02                              shl     manA, #2                ' left justify mantissa
024C 065 84FFCA1F                              sub     expA, #31               ' our target exponent is 31
0250 066 ABBFCBE5                              abs     expA, expA      wc,wz
0254 067 A4C7C601                    if_a      neg     fnumA, #1               ' if we needed to shift left, we're already maxed out
0258 068 857BCA20                    if_be     cmp     expA, #32       wc      ' otherwise, if we need to shift right by more than 31, the answer is 0
025C 069 28B3CDE5                    if_c      shr     manA, expA              ' OK, shift it down
0260 06A A0B3C7E6                    if_c      mov     fnumA, manA
0264 06B 5C7C0000      _UintTrunc_ret          ret
0268 06C 5CFE952D      _FSqr                   call    #_Unpack                 ' unpack floating point value
026C 06D 5C380080                if_c_or_z     jmp     _FSqr_ret               ' check for NaN or zero
0270 06E 627FC801                              test    flagA, #SignFlag wz      ' check for negative
0274 06F A097C7CF                if_nz         mov     fnumA, NaN               ' yes, then return NaN
0278 070 5C140080                if_nz         jmp     _FSqr_ret
027C 071 39FFCA01                              sar     expA, #1 wc             ' if odd exponent, shift mantissa
0280 072 2CF3CC01                if_c          shl     manA, #1
0284 073 80FFCA01                              add     expA, #1
0288 074 A0FFBA1D                              mov     t2, #29
028C 075 A0FFC600                              mov     fnumA, #0               ' set initial result to zero
0290 076               :sqrt                   ' what is the delta root^2 if we add in this bit?
0290 076 A0BFBDE3                              mov     t3, fnumA
0294 077 2CFFBC02                              shl     t3, #2
0298 078 80FFBC01                              add     t3, #1
029C 079 2CBFBDDD                              shl     t3, t2
02A0 07A E1BFCDDE                              cmpsub  manA, t3        wc
02A4 07B 34FFC601                              rcl     fnumA, #1
02A8 07C 2CFFCC01                              shl     manA, #1
02AC 07D E4FFBA76                              djnz    t2, #:sqrt
02B0 07E A0BFCDE3                              mov     manA, fnumA             ' store new mantissa value and exit
02B4 07F 5CFEC14B                              call    #_Pack
02B8 080 5C7C0000      _FSqr_ret               ret
02BC 081 A0BFB9E3      _FCmp                   mov     t1, fnumA               ' if both values...
02C0 082 60BFB9E7                              and     t1, fnumB               '  are negative...
02C4 083 2DFFB801                              shl     t1, #1 wc               ' (bit 31 high)...
02C8 084 B0FFB801                              negc    t1, #1                  ' then the comparison will be reversed
02CC 085 C33FC7E7                              cmps    fnumA, fnumB wc,wz      ' do the signed comparison, save result in flags C Z
02D0 086 A0EBB800                    if_z      mov     t1, #0
02D4 087 68BFC7E7                              or      fnumA, fnumB            ' +0 == -0, so compare for both being 0...
02D8 088 66BFC7D7                              andn    fnumA, Bit31 wz         ' ignoring bit 31, will be 0 if both fA and fB were zero
02DC 089 B097C7DC                    if_nz     negc    fnumA, t1               ' if it's not zero
02E0 08A 5C7C0000      _FCmp_ret               ret
02E4 08B               _Table_Interp           ' store the fractional part
02E4 08B A0BFBFDC                              mov     t4, t1                  ' will store reversed so a SAR will shift the value and get a bit
02E8 08C 3CFFBE0C                              rev     t4, #12                 ' ignore the top 12 bits, and reverse the rest
02EC 08D 28FFB813                              shr     t1, #19
02F0 08E 613FBBDA                              test    t2, SineTable    wc      'C = 1 if we're doing a SINE table lookup.  added to fix LOG and SIN
02F4 08F 80BFBBDC                              add     t2, t1
02F8 090 04BFB9DD                              rdword  t1, t2
02FC 091 2CFFB80E                              shl     t1, #14
0300 092 80FFBA02                              add     t2, #2
0304 093 623FBBD3                              test    t2, TableMask   wz      'table address has overflowed.  added to fix LOG
0308 094 A08BBBD4              if_z_and_nc     mov     t2, Bit16               'fix table value unless we're doing the SINE table.  added to fix LOG
030C 095 04B7BBDD              if_nz_or_c      rdword  t2, t2                  'else, look up the correct value.  conditional added to fix LOG
0310 096 2CFFBA0E                              shl     t2, #14
0314 097 84BFBBDC                              sub     t2, t1                  ' change from 2 points to delta
0318 098 50BFBBDF                              movs    t2, t4                  ' make the low 9 bits the multiplier (reversed)
031C 099 A0FFBC09                              mov     t3, #9                  ' do 9 steps
0320 09A 39FFBA01      :interp                 sar     t2, #1          wc      ' divide the delta by 2, and get the MSB multiplier bit
0324 09B 80B3B9DD                    if_c      add     t1, t2                  ' if the multiplier bit was 1, add in the shifter delta
0328 09C E4FFBC9A                              djnz    t3, #:interp            ' keep going, 9 times around
032C 09D 5C7C0000      _Table_Interp_ret       ret
0330 09E 3E22F983      OneOver2Pi              long    1.0 / (2.0 * pi)        ' I need this constant to get the fractional angle
0334 09F A0BFBFD5      _Cos                    mov     t4, Bit29               ' adjust sine to cosine at the last possible minute by adding 90 degrees
0338 0A0 64BFC7D7                              andn    fnumA, Bit31            ' nuke the sign bit
033C 0A1 5C7C00A3                              jmp     #_SinCos_cont
0340 0A2 A0FFBE00      _Sin                    mov     t4, #0                  ' just sine, and keep my sign bit
0344 0A3 A0BFCE9E      _SinCos_cont            mov     fnumB, OneOver2Pi
0348 0A4 5CFC641F                              call    #_FMul                  ' rescale angle from [0..2pi] to [0..1]
034C 0A5 5CFE952D                              call    #_Unpack
0350 0A6 80FFCA02                              add     expA, #2                ' bias the exponent by 3 so the resulting data will be 31-bit aligned
0354 0A7 A9BFCBE5                              abs     expA, expA      wc      ' was the exponent positive or negative?
0358 0A8 4CFFCA1F                              max     expA, #31               ' limit to 31, otherwise we do weird wrapping things
035C 0A9 28B3CDE5                    if_c      shr     manA, expA              ' -exp: shift right to bring down to 1.0
0360 0AA 2C8FCDE5                    if_nc     shl     manA, expA              ' +exp: shift left to throw away the high bits
0364 0AB A0BFC3E6                              mov     t6, manA                ' store the address in case Tan needs it
0368 0AC 80BFCDDF                              add     manA, t4                ' adjust for cosine?
036C 0AD 623FCDD5      _resume_Tan             test    manA, Bit29     wz
0370 0AE BCBFB9E6                              negnz   t1, manA
0374 0AF 2CFFB802                              shl     t1, #2
0378 0B0 A0BFBBDA                              mov     t2, SineTable
037C 0B1 5CFD3A8B                              call    #_Table_Interp
0380 0B2 623FCDD6                              test    manA, Bit30     wz      ' check if we're in quadrant 3 or 4
0384 0B3 A8BFCDDC                              abs     manA, t1                ' move my number into the mantissa
0388 0B4 28FFCC10                              shr     manA, #16               ' but the table went to $FFFF, so scale up a bit to
038C 0B5 88BFCDDC                              addabs  manA, t1                ' get to &10000
0390 0B6 6CD7C801                    if_nz     xor     flagA, #SignFlag        ' invert my sign bit, if the mantissa would have been negative (quad 3 or 4)
0394 0B7 A4FFCA01                              neg     expA, #1                ' exponent is -1
0398 0B8 5CFEC14B                              call    #_Pack
039C 0B9               _resume_Tan_ret
039C 0B9               _Cos_ret
039C 0B9 5C7C0000      _Sin_ret                ret
03A0 0BA 5CFD72A2      _Tan                    call    #_Sin
03A4 0BB A0BFC5E3                              mov     t7, fnumA
03A8 0BC A0BFCDE1                              mov     manA, t6                ' was manA for Sine
03AC 0BD 80BFCDD5                              add     manA, Bit29             ' add in 90 degrees
03B0 0BE 5CFD72AD                              call    #_resume_Tan            ' go back and recompute the float
03B4 0BF A0BFCFE3                              mov     fnumB, fnumA            ' move Cosine into fnumB
03B8 0C0 A0BFC7E2                              mov     fnumA, t7               ' move Sine into fnumA
03BC 0C1 5CFC8233                              call    #_FDiv                  ' divide
03C0 0C2 5C7C0000      _Tan_ret                ret
03C4 0C3 5CFE952D      _Log2                   call    #_Unpack                ' unpack variable
03C8 0C4 6147C801                if_nz_and_nc  test    flagA, #SignFlag wc     ' if NaN or <= 0, return NaN
03CC 0C5 5C7800D7                if_z_or_c     jmp     #:exitNaN
03D0 0C6 A0BFB9E6                              mov     t1, manA
03D4 0C7 2CFFB803                              shl     t1, #3
03D8 0C8 28FFB801                              shr     t1, #1
03DC 0C9 A0BFBBD8                              mov     t2, LogTable
03E0 0CA 5CFD3A8B                              call    #_Table_Interp
03E4 0CB A0BFCDDC                              mov     manA, t1
03E8 0CC 28FFCC05                              shr     manA, #5                  ' clear the top 7 bits (already 2 free
03EC 0CD A9BFCBE5                              abs     expA, expA      wc
03F0 0CE 70FFC801                              muxc    flagA, #SignFlag
03F4 0CF 2CFFCA19                              shl     expA, #25
03F8 0D0 B0BFCDE6                              negc    manA, manA
03FC 0D1 80BFCDE5                              add     manA, expA
0400 0D2 A0FFCA04                              mov     expA, #4
0404 0D3 5CFEC14B                              call    #_Pack
0408 0D4 867FCE00                              cmp     fnumB, #0    wz         ' check that my divisor isn't 0 (which flags that we're doing log2)
040C 0D5 5CD48233                    if_nz     call    #_FDiv                  ' convert the base (unless fnumB was 0)
0410 0D6 5C3C00D8                              jmp     _Log2_ret
0414 0D7 A0BFC7CF      :exitNaN                mov     fnumA, NaN              ' return NaN
0418 0D8 5C7C0000      _Log2_ret               ret
041C 0D9 867FCE00      _Exp2                   cmp     fnumB, #0       wz
0420 0DA 5CD4641F                    if_nz     call    #_FMul
0424 0DB 5CFE952D                              call    #_Unpack
0428 0DC 2CFFCC02                              shl     manA, #2                ' left justify mantissa
042C 0DD A0BFB9E5                              mov     t1, expA                ' copy the local exponent
0430 0DE 84FFB81E                              sub     t1, #30                 ' our target exponent is 31
0434 0DF A9BFCBDC                              abs     expA, t1      wc        ' adjust for exponent sign, and track if it was negative
0438 0E0 5C7000E5                    if_c      jmp     #:cont_Exp2
043C 0E1 627FC801                              test    flagA, #SignFlag wz
0440 0E2 A0ABC7CF                    if_z      mov     fnumA, NaN              ' nope, was positive, bail with NaN (happens to be the largest positive integer)
0444 0E3 A0D7C600                    if_nz     mov     fnumA, #0
0448 0E4 5C3C00FD                              jmp     _Exp2_ret
044C 0E5 A0BFBBE6      :cont_Exp2              mov     t2, manA
0450 0E6 4CFFCA1F                              max     expA, #31
0454 0E7 28BFBBE5                              shr     t2, expA
0458 0E8 28FFBA01                              shr     t2, #1
045C 0E9 A0BFCBDD                              mov     expA, t2
0460 0EA 80FFB81F                              add     t1, #31
0464 0EB A9BFBBDC                              abs     t2, t1          wc
0468 0EC 28B3CDDD                    if_c      shr     manA, t2
046C 0ED 2C8FCDDD                    if_nc     shl     manA, t2
0470 0EE A0BFB9E6                              mov     t1, manA
0474 0EF 28FFB801                              shr     t1, #1
0478 0F0 A0BFBBD9                              mov     t2, ALogTable
047C 0F1 5CFD3A8B                              call    #_Table_Interp
0480 0F2 A0BFC3E4                              mov     t6, flagA
0484 0F3 A0BFCDDC                              mov     manA, t1
0488 0F4 68BFCDD6                              or      manA, Bit30
048C 0F5 84FFCA01                              sub     expA, #1
0490 0F6 A0FFC800                              mov     flagA, #0
0494 0F7 5CFEC14B                              call    #_Pack
0498 0F8 627FC201                              test    t6, #SignFlag wz        ' check sign and store this back in the exponent
049C 0F9 5C2800FD                    if_z      jmp     _Exp2_ret
04A0 0FA A0BFCFE3                              mov     fnumB, fnumA            ' yes, then invert
04A4 0FB A0BFC7CE                              mov     fnumA, One
04A8 0FC 5CFC8233                              call    #_FDiv
04AC 0FD 5C7C0000      _Exp2_ret               ret
04B0 0FE A1BFC5E3      _Pow                    mov     t7, fnumA wc            ' save sign of result
04B4 0FF 5C4C010E                if_nc         jmp     #:pow3                  ' check if negative base
04B8 100 A0BFC7E7                              mov     fnumA, fnumB            ' check exponent
04BC 101 5CFE952D                              call    #_Unpack
04C0 102 A0BFC7E2                              mov     fnumA, t7               ' restore base
04C4 103 5C68010C                if_z          jmp     #:pow2                  ' check for exponent = 0
04C8 104 623FCBD7                              test    expA, Bit31 wz          ' if exponent < 0, return NaN
04CC 105 5C54010A                if_nz         jmp     #:pow1
04D0 106 4CFFCA17                              max     expA, #23               ' check if exponent = integer
04D4 107 2CBFCDE5                              shl     manA, expA
04D8 108 623FCDD2                              and     manA, Mask29 wz, nr
04DC 109 5C68010C                if_z          jmp     #:pow2                  ' yes, then check if odd
04E0 10A A0BFC7CF      :pow1                   mov     fnumA, NaN              ' return NaN
04E4 10B 5C3C0116                              jmp     _Pow_ret
04E8 10C 623FCDD5      :pow2                   test    manA, Bit29 wz          ' if odd, then negate result
04EC 10D 64ABC5D7                if_z          andn    t7, Bit31
04F0 10E 64BFC7D7      :pow3                   andn    fnumA, Bit31            ' get |fnumA|
04F4 10F A0BFC3E7                              mov     t6, fnumB               ' save power
04F8 110 5CFDB0C3                              call    #_Log2                  ' get log of base
04FC 111 A0BFCFE1                              mov     fnumB, t6               ' multiply by power
0500 112 5CFC641F                              call    #_FMul
0504 113 5CFDFAD9                              call    #_Exp2                  ' get result
0508 114 623FC5D7                              test    t7, Bit31 wz            ' check for negative
050C 115 6C97C7D7                if_nz         xor     fnumA, Bit31
0510 116 5C7C0000      _Pow_ret                ret
0514 117 5CFE952D      _Frac                   call    #_Unpack                ' get fraction
0518 118 623FCBD7                              test    expA, Bit31 wz          ' check for exp < 0 or NaN
051C 119 5C74011E                if_c_or_nz    jmp     #:exit
0520 11A 4CFFCA17                              max     expA, #23               ' remove the integer
0524 11B 2CBFCDE5                              shl     manA, expA
0528 11C 60BFCDD2                              and     manA, Mask29
052C 11D A0FFCA00                              mov     expA, #0                ' return fraction
0530 11E 5CFEC14B      :exit                   call    #_Pack
0534 11F 64BFC7D7                              andn    fnumA, Bit31
0538 120 5C7C0000      _Frac_ret               ret
053C 121 A0BFB9E3      _Unpack2                mov     t1, fnumA               ' save A
0540 122 A0BFC7E7                              mov     fnumA, fnumB            ' unpack B to A
0544 123 5CFE952D                              call    #_Unpack
0548 124 5C30012C                if_c          jmp     _Unpack2_ret           ' check for NaN
054C 125 A0BFCFE3                              mov     fnumB, fnumA            ' save B variables
0550 126 A0BFD1E4                              mov     flagB, flagA
0554 127 A0BFD3E5                              mov     expB, expA
0558 128 A0BFD5E6                              mov     manB, manA
055C 129 A0BFC7DC                              mov     fnumA, t1               ' unpack A
0560 12A 5CFE952D                              call    #_Unpack
0564 12B 867FD400                              cmp     manB, #0 wz             ' set Z flag
0568 12C 5C7C0000      _Unpack2_ret            ret
056C 12D A0BFC9E3      _Unpack                 mov     flagA, fnumA            ' get sign
0570 12E 28FFC81F                              shr     flagA, #31
0574 12F A0BFCDE3                              mov     manA, fnumA             ' get mantissa
0578 130 60BFCDD1                              and     manA, Mask23
057C 131 A0BFCBE3                              mov     expA, fnumA             ' get exponent
0580 132 2CFFCA01                              shl     expA, #1
0584 133 2AFFCA18                              shr     expA, #24 wz
0588 134 5C68013A                if_z          jmp     #:zeroSubnormal         ' check for zero or subnormal
058C 135 867FCAFF                              cmp     expA, #255 wz           ' check if finite
0590 136 5C540145                if_nz         jmp     #:finite
0594 137 A0BFC7CF                              mov     fnumA, NaN              ' no, then return NaN
0598 138 A0FFC808                              mov     flagA, #NaNFlag
059C 139 5C7C0148                              jmp     #:exit2
05A0 13A 6A3FCDE5      :zeroSubnormal          or      manA, expA wz,nr        ' check for zero
05A4 13B 5C54013F                if_nz         jmp     #:subnorm
05A8 13C 68FFC802                              or      flagA, #ZeroFlag        ' yes, then set zero flag
05AC 13D A4FFCA96                              neg     expA, #150              ' set exponent and exit
05B0 13E 5C7C0148                              jmp     #:exit2
05B4 13F 2CFFCC07      :subnorm                shl     manA, #7                ' fix justification for subnormals
05B8 140 623FCDD5      :subnorm2               test    manA, Bit29 wz
05BC 141 5C540147                if_nz         jmp     #:exit1
05C0 142 2CFFCC01                              shl     manA, #1
05C4 143 84FFCA01                              sub     expA, #1
05C8 144 5C7C0140                              jmp     #:subnorm2
05CC 145 2CFFCC06      :finite                 shl     manA, #6                ' justify mantissa to bit 29
05D0 146 68BFCDD5                              or      manA, Bit29             ' add leading one bit
05D4 147 84FFCA7F      :exit1                  sub     expA, #127              ' remove bias from exponent
05D8 148 617FC808      :exit2                  test    flagA, #NaNFlag wc      ' set C flag
05DC 149 867FCC00                              cmp     manA, #0 wz             ' set Z flag
05E0 14A 5C7C0000      _Unpack_ret             ret
05E4 14B 867FCC00      _Pack                   cmp     manA, #0 wz             ' check for zero
05E8 14C A0EBCA00                if_z          mov     expA, #0
05EC 14D 5C68015B                if_z          jmp     #:exit1
05F0 14E 84FFCB7C                              sub     expA, #380              ' take us out of the danger range for djnz
05F4 14F 2DFFCC01      :normalize              shl     manA, #1 wc             ' normalize the mantissa
05F8 150 E4CFCB4F                if_nc         djnz    expA, #:normalize       ' adjust exponent and jump
05FC 151 81FFCD00                              add     manA, #$100 wc          ' round up by 1/2 lsb
0600 152 C8FFCBFD                              addx    expA, #(380 + 127 + 2)  ' add bias to exponent, account for rounding (in flag C, above)
0604 153 40BFCBD0                              mins    expA, Minus23
0608 154 44FFCAFF                              maxs    expA, #255
060C 155 ABBFCBE5                              abs     expA, expA wc,wz        ' check for subnormals, and get the abs in case it is
0610 156 5C44015B                if_a          jmp     #:exit1
0614 157 68FFCC01      :subnormal              or      manA, #1                ' adjust mantissa
0618 158 20FFCC01                              ror     manA, #1
061C 159 28BFCDE5                              shr     manA, expA
0620 15A A0FFCA00                              mov     expA, #0                ' biased exponent = 0
0624 15B A0BFC7E6      :exit1                  mov     fnumA, manA             ' bits 22:0 mantissa
0628 15C 28FFC609                              shr     fnumA, #9
062C 15D 58BFC7E5                              movi    fnumA, expA             ' bits 23:30 exponent
0630 15E 2CFFC81F                              shl     flagA, #31
0634 15F 68BFC7E4                              or      fnumA, flagA            ' bit 31 sign
0638 160 5C7C0000      _Pack_ret               ret
063C 161 A0BFBFE3      _FMod                   mov     t4, fnumA               ' save fnumA
0640 162 A0BFC1E7                              mov     t5, fnumB               ' save fnumB
0644 163 5CFC8233                              call    #_FDiv                  ' a - float(fix(a/b)) * b
0648 164 A0FFCE00                              mov     fnumB, #0
064C 165 5CFCBE48                              call    #_FTruncRound
0650 166 5CFC8E42                              call    #_FFloat
0654 167 A0BFCFE0                              mov     fnumB, t5
0658 168 5CFC641F                              call    #_FMul
065C 169 68BFC7D7                              or      fnumA, Bit31
0660 16A A0BFCFDF                              mov     fnumB, t4
0664 16B 64BFCFD7                              andn    fnumB, Bit31
0668 16C 5CFC3C0D                              call    #_FAdd
066C 16D 623FBFD7                              test    t4, Bit31 wz            ' if a < 0, set sign
0670 16E 6897C7D7                if_nz         or      fnumA, Bit31
0674 16F 5C7C0000      _FMod_ret               ret
0678 170 5CFE5921      _ATan2                  call    #_Unpack2               ' OK, start with the basics
067C 171 A0FFC600                              mov     fnumA, #0               ' clear my accumulator
0680 172 84BFCBE9                              sub     expA, expB
0684 173 A9BFCBE5                              abs     expA, expA      wc
0688 174 28FFCC01                              shr     manA, #1
068C 175 28FFD401                              shr     manB, #1
0690 176 28B3CDE5                    if_c      shr     manA, expA
0694 177 288FD5E5                    if_nc     shr     manB, expA
0698 178 617FC801                              test    flagA, #SignFlag wc
069C 179 627FD001                              test    flagB, #SignFlag wz
06A0 17A A4A7CDE6                    if_z_eq_c neg     manA, manA
06A4 17B 9097C78E                    if_nz     sumc    fnumA, CORDIC_Pi
06A8 17C A0FFB800                              mov     t1, #0
06AC 17D A0FFBA19                              mov     t2, #25                 ' 20 gets you the same error range as the original, 29 is best, 25 is a nice compromise
06B0 17E 50FF0B8F                              movs    :load_C_table, #CORDIC_Angles
06B4 17F               :CORDIC                 ' do the actual CORDIC thing
06B4 17F A1BFBDE6                              mov     t3, manA        wc      ' mark whether our Y component is negative or not
06B8 180 38BFBDDC                              sar     t3, t1
06BC 181 A0BFBFEA                              mov     t4, manB
06C0 182 38BFBFDC                              sar     t4, t1
06C4 183 90BFD5DE                              sumc    manB, t3                ' C determines the direction of the rotation
06C8 184 96BFCDDF                              sumnc   manA, t4        wz      ' (be ready to short-circuit as soon as the Y component is 0)
06CC 185 90BFC600      :load_C_table           sumc    fnumA, 0-0
06D0 186 80FF0A01                              add     :load_C_table, #1
06D4 187 80FFB801                              add     t1, #1
06D8 188 E4FFBB7F                              djnz    t2, #:CORDIC
06DC 189 A0FFCA01                              mov     expA, #1
06E0 18A A9BFCDE3                              abs     manA, fnumA     wc
06E4 18B 70FFC801                              muxc    flagA, #SignFlag
06E8 18C 5CFEC14B                              call    #_Pack
06EC 18D 5C7C0000      _ATan2_ret              ret
06F0 18E 3243F6A8      CORDIC_Pi               long    $3243f6a8       ' Pi in 30 bits (otherwise we can overflow)
06F4 18F 0C90FDAA      CORDIC_Angles           long $c90fdaa, $76b19c1, $3eb6ebf, $1fd5ba9, $ffaadd
06F8 190 076B19C1 03EB6EBF 01FD5BA9 00FFAADD
0708 194 007FF556                              long $7ff556, $3ffeaa, $1fffd5, $ffffa, $7ffff
070C 195 003FFEAA 001FFFD5 000FFFFA 0007FFFF
071C 199 0003FFFF                              long $3ffff, $20000, $10000, $8000, $4000
0720 19A 00020000 00010000 00008000 00004000
0730 19E 00002000                              long $2000, $1000, $800, $400, $200
0734 19F 00001000 00000800 00000400 00000200
0744 1A3 00000100                              long $100, $80, $40, $20, $10
0748 1A4 00000080 00000040 00000020 00000010
0758 1A8               _ASinCos                ' grab a copy of both operands
0758 1A8 A0BFC1E3                              mov     t5, fnumA
075C 1A9 A0BFC3E7                              mov     t6, fnumB
0760 1AA A0BFCFE3                              mov     fnumB, fnumA
0764 1AB 5CFC641F                              call    #_FMul
0768 1AC A0BFCFE3                              mov     fnumB, fnumA
076C 1AD A0BFC7CE                              mov     fnumA, One
0770 1AE 5CFC3C0C                              call    #_FSub
0774 1AF 613FC7D7                              test    fnumA, Bit31    wc
0778 1B0 A0B3C7CF                    if_c      mov     fnumA, NaN
077C 1B1 5C3001B8                    if_c      jmp     _ASinCos_ret
0780 1B2 5CFD006C                              call    #_FSqr
0784 1B3 A2BFC3E1                              mov     t6, t6          wz
0788 1B4 A0ABCFE0                    if_z      mov     fnumB, t5
078C 1B5 A097CFE3                    if_nz     mov     fnumB, fnumA
0790 1B6 A097C7E0                    if_nz     mov     fnumA, t5
0794 1B7 5CFF1B70                              call    #_ATan2
0798 1B8 5C7C0000      _ASinCos_ret            ret
079C 1B9 A0FFC201      _Ceil                   mov     t6, #1                  ' set adjustment value
07A0 1BA 5C7C01BC                              jmp     #floor2
07A4 1BB A4FFC201      _Floor                  neg     t6, #1                  ' set adjustment value
07A8 1BC 5CFE952D      floor2                  call    #_Unpack                ' unpack variable
07AC 1BD 5C3001CD                if_c          jmp     _Floor_ret             ' check for NaN
07B0 1BE C37FCA17                              cmps     expA, #23 wc, wz       ' check for no fraction
07B4 1BF 5C0C01CD                if_nc         jmp     _Floor_ret
07B8 1C0 A0BFBFE3                              mov     t4, fnumA               ' get integer value
07BC 1C1 A0FFCE00                              mov     fnumB, #0
07C0 1C2 5CFCBE48                              call    #_FTruncRound
07C4 1C3 A0BFC1E3                              mov     t5, fnumA
07C8 1C4 6CBFC7E1                              xor     fnumA, t6
07CC 1C5 623FC7D7                              test    fnumA, Bit31 wz
07D0 1C6 5C5401CB                if_nz         jmp     #:exit
07D4 1C7 A0BFC7DF                              mov     fnumA, t4               ' get fraction
07D8 1C8 5CFE4117                              call    #_Frac
07DC 1C9 6ABFC7E3                              or      fnumA, fnumA wz
07E0 1CA 8097C1E1                if_nz         add     t5, t6                  ' if non-zero, then adjust
07E4 1CB A0BFC7E0      :exit                   mov     fnumA, t5               ' convert integer to float
07E8 1CC 5CFC8E42                              call    #_FFloat                '}
07EC 1CD               _Ceil_ret
07EC 1CD 5C7C0000      _Floor_ret              ret
07F0 1CE 3F800000      One                     long    1.0
07F4 1CF 7FFFFFFF      NaN                     long    $7FFF_FFFF
07F8 1D0 FFFFFFE9      Minus23                 long    -23
07FC 1D1 007FFFFF      Mask23                  long    $007F_FFFF
0800 1D2 1FFFFFFF      Mask29                  long    $1FFF_FFFF
0804 1D3 00000FFE      TableMask               long    $0FFE           'added to fix LOG
0808 1D4 00010000      Bit16                   long    $0001_0000       'added to fix LOG
080C 1D5 20000000      Bit29                   long    $2000_0000
0810 1D6 40000000      Bit30                   long    $4000_0000
0814 1D7 80000000      Bit31                   long    $8000_0000
0818 1D8 0000C000      LogTable                long    $C000
081C 1D9 0000D000      ALogTable               long    $D000
0820 1DA 0000E000      SineTable               long    $E000
0824 1DB               ret_ptr                 res     1
0824 1DC               t1                      res     1
0824 1DD               t2                      res     1
0824 1DE               t3                      res     1
0824 1DF               t4                      res     1
0824 1E0               t5                      res     1
0824 1E1               t6                      res     1
0824 1E2               t7                      res     1
0824 1E3               fnumA                   res     1               ' floating point A value
0824 1E4               flagA                   res     1
0824 1E5               expA                    res     1
0824 1E6               manA                    res     1
0824 1E7               fnumB                   res     1               ' floating point B value
0824 1E8               flagB                   res     1
0824 1E9               expB                    res     1
0824 1EA               manB                    res     1
0824 1EB               fit 496 ' A cog has 496 longs available, the last 16 (to make it up to 512) are register shadows.
0824 1EB               cmdCallTable
0824 1EB 5CFC3C0D      cmdFAdd                 call    #_FAdd
0828 1EC 5CFC3C0C      cmdFSub                 call    #_FSub
082C 1ED 5CFC641F      cmdFMul                 call    #_FMul
0830 1EE 5CFC8233      cmdFDiv                 call    #_FDiv
0834 1EF 5CFC8E42      cmdFFloat               call    #_FFloat
0838 1F0 5CFCBE48      cmdFTruncRound          call    #_FTruncRound
083C 1F1 5CFCD660      cmdUintTrunc            call    #_UintTrunc
0840 1F2 5CFD006C      cmdFSqr                 call    #_FSqr
0844 1F3 5CFD1481      cmdFCmp                 call    #_FCmp
0848 1F4 5CFD72A2      cmdFSin                 call    #_Sin
084C 1F5 5CFD729F      cmdFCos                 call    #_Cos
0850 1F6 5CFD84BA      cmdFTan                 call    #_Tan
0854 1F7 5CFDB0C3      cmdFLog2                call    #_Log2
0858 1F8 5CFDFAD9      cmdFExp2                call    #_Exp2
085C 1F9 5CFE2CFE      cmdFPow                 call    #_Pow
0860 1FA 5CFE4117      cmdFFrac                call    #_Frac
0864 1FB 5CFEDF61      cmdFMod                 call    #_FMod
0868 1FC 5CFF71A8      cmdASinCos              call    #_ASinCos
086C 1FD 5CFF1B70      cmdATan2                call    #_ATan2
0870 1FE 5CFF9BB9      cmdCeil                 call    #_Ceil
0874 1FF 5CFF9BBB      cmdFloor                call    #_Floor
0878                   PUB Start
0878                       Stop
0878     01            ; Frame_Call_Noreturn
0879     05 02         ; Call, $02
087B                       f32_Cmd := 0
087B     35            ; Push_0
087C     41            ; Pop_VariableMem_Long_0
087D                       return cog := cognew(@f32_entry, @f32_Cmd) + 1
087D     34            ; Push_Neg1
087E     C7 80 A8      ; Reference_ObjectMem_Long, $00A8
0881     43            ; Reference_VariableMem_Long_0
0882     28            ; Coginit_Returns
0883     36            ; Push_1
0884     EC            ; Add
0885     8A 04 80      ; Effect_VariableMem_Byte, $0004, write, push
0888     33            ; Pop_Return
0889     32            ; Return
088A                   PUB Stop
088A                       if cog
088A     88 04         ; Push_VariableMem_Byte, $0004
088C     0A 06         ; Jump_If_False, $0006
088E                           cogstop(cog~ - 1)
088E     8A 04 98      ; Effect_VariableMem_Byte, $0004, post-clear, push
0891     36            ; Push_1
0892     ED            ; Subtract
0893     21            ; Cogstop
0894     32            ; Return
0895                   PUB FloatF(a)
0895                       return SetCommand(a, 0, cmdFFloat)
0895     00            ; Frame_Call_Return
0896     64            ; Push_LocalMem_Long_1
0897     35            ; Push_0
0898     C4 88 24      ; Push_ObjectMem_Long, $0824
089B     05 29         ; Call, $29
089D     33            ; Pop_Return
089E     32            ; Return
089F                   PUB RoundF(a)
089F                       return SetCommand(a, %011, cmdFTruncRound)
089F     00            ; Frame_Call_Return
08A0     64            ; Push_LocalMem_Long_1
08A1     37 21         ; Push_Packed_Lit, $00000003
08A3     C4 88 28      ; Push_ObjectMem_Long, $0828
08A6     05 29         ; Call, $29
08A8     33            ; Pop_Return
08A9     32            ; Return
08AA                   PUB TruncF(a)
08AA                       return SetCommand(a, %010, cmdFTruncRound)
08AA     00            ; Frame_Call_Return
08AB     64            ; Push_LocalMem_Long_1
08AC     37 00         ; Push_Packed_Lit, $00000002
08AE     C4 88 28      ; Push_ObjectMem_Long, $0828
08B1     05 29         ; Call, $29
08B3     33            ; Pop_Return
08B4     32            ; Return
08B5                   PUB TruncUInt(a)
08B5                       return SetCommand(a, 0, cmdUintTrunc)
08B5     00            ; Frame_Call_Return
08B6     64            ; Push_LocalMem_Long_1
08B7     35            ; Push_0
08B8     C4 88 2C      ; Push_ObjectMem_Long, $082C
08BB     05 29         ; Call, $29
08BD     33            ; Pop_Return
08BE     32            ; Return
08BF                   PUB TruncFInt(a)
08BF                       return SetCommand(a, %000, cmdFTruncRound)
08BF     00            ; Frame_Call_Return
08C0     64            ; Push_LocalMem_Long_1
08C1     35            ; Push_0
08C2     C4 88 28      ; Push_ObjectMem_Long, $0828
08C5     05 29         ; Call, $29
08C7     33            ; Pop_Return
08C8     32            ; Return
08C9                   PUB RoundFInt(a)
08C9                       return SetCommand(a, %001, cmdFTruncRound)
08C9     00            ; Frame_Call_Return
08CA     64            ; Push_LocalMem_Long_1
08CB     36            ; Push_1
08CC     C4 88 28      ; Push_ObjectMem_Long, $0828
08CF     05 29         ; Call, $29
08D1     33            ; Pop_Return
08D2     32            ; Return
08D3                   PUB NegF(a)
08D3                       return a ^ $8000_0000
08D3     64            ; Push_LocalMem_Long_1
08D4     37 1E         ; Push_Packed_Lit, $80000000
08D6     EB            ; Bit_Xor
08D7     33            ; Pop_Return
08D8     32            ; Return
08D9                   PUB AbsF(a)
08D9                       return a & $7FFF_FFFF
08D9     64            ; Push_LocalMem_Long_1
08DA     37 3E         ; Push_Packed_Lit, $7FFFFFFF
08DC     E8            ; Bit_And
08DD     33            ; Pop_Return
08DE     32            ; Return
08DF                   PUB AddF(a, b)
08DF                       return SetCommand(a, b, cmdFAdd)
08DF     00            ; Frame_Call_Return
08E0     64            ; Push_LocalMem_Long_1
08E1     68            ; Push_LocalMem_Long_2
08E2     C4 88 14      ; Push_ObjectMem_Long, $0814
08E5     05 29         ; Call, $29
08E7     33            ; Pop_Return
08E8     32            ; Return
08E9                   PUB SubF(a, b)
08E9                       return SetCommand(a, b, cmdFSub)
08E9     00            ; Frame_Call_Return
08EA     64            ; Push_LocalMem_Long_1
08EB     68            ; Push_LocalMem_Long_2
08EC     C4 88 18      ; Push_ObjectMem_Long, $0818
08EF     05 29         ; Call, $29
08F1     33            ; Pop_Return
08F2     32            ; Return
08F3                   PUB MulF(a, b)
08F3                       return SetCommand(a, b, cmdFMul)
08F3     00            ; Frame_Call_Return
08F4     64            ; Push_LocalMem_Long_1
08F5     68            ; Push_LocalMem_Long_2
08F6     C4 88 1C      ; Push_ObjectMem_Long, $081C
08F9     05 29         ; Call, $29
08FB     33            ; Pop_Return
08FC     32            ; Return
08FD                   PUB DivF(a, b)
08FD                       return SetCommand(a, b, cmdFDiv)
08FD     00            ; Frame_Call_Return
08FE     64            ; Push_LocalMem_Long_1
08FF     68            ; Push_LocalMem_Long_2
0900     C4 88 20      ; Push_ObjectMem_Long, $0820
0903     05 29         ; Call, $29
0905     33            ; Pop_Return
0906     32            ; Return
0907                   PUB ModF(a, b)
0907                       return SetCommand(a, b, cmdFMod)
0907     00            ; Frame_Call_Return
0908     64            ; Push_LocalMem_Long_1
0909     68            ; Push_LocalMem_Long_2
090A     C4 88 54      ; Push_ObjectMem_Long, $0854
090D     05 29         ; Call, $29
090F     33            ; Pop_Return
0910     32            ; Return
0911                   PUB CmpF(a, b)
0911                       return SetCommand(a, b, cmdFCmp)
0911     00            ; Frame_Call_Return
0912     64            ; Push_LocalMem_Long_1
0913     68            ; Push_LocalMem_Long_2
0914     C4 88 34      ; Push_ObjectMem_Long, $0834
0917     05 29         ; Call, $29
0919     33            ; Pop_Return
091A     32            ; Return
091B                   PUB Sqrt(a)
091B                       return SetCommand(a, 0, cmdFSqr)
091B     00            ; Frame_Call_Return
091C     64            ; Push_LocalMem_Long_1
091D     35            ; Push_0
091E     C4 88 30      ; Push_ObjectMem_Long, $0830
0921     05 29         ; Call, $29
0923     33            ; Pop_Return
0924     32            ; Return
0925                   PUB Sin(a)
0925                       return SetCommand(a, 0, cmdFSin)
0925     00            ; Frame_Call_Return
0926     64            ; Push_LocalMem_Long_1
0927     35            ; Push_0
0928     C4 88 38      ; Push_ObjectMem_Long, $0838
092B     05 29         ; Call, $29
092D     33            ; Pop_Return
092E     32            ; Return
092F                   PUB Cos(a)
092F                       return SetCommand(a, 0, cmdFCos)
092F     00            ; Frame_Call_Return
0930     64            ; Push_LocalMem_Long_1
0931     35            ; Push_0
0932     C4 88 3C      ; Push_ObjectMem_Long, $083C
0935     05 29         ; Call, $29
0937     33            ; Pop_Return
0938     32            ; Return
0939                   PUB Tan(a)
0939                       return SetCommand(a, 0, cmdFTan)
0939     00            ; Frame_Call_Return
093A     64            ; Push_LocalMem_Long_1
093B     35            ; Push_0
093C     C4 88 40      ; Push_ObjectMem_Long, $0840
093F     05 29         ; Call, $29
0941     33            ; Pop_Return
0942     32            ; Return
0943                   PUB Log(a)
0943                       return SetCommand(a, 1.442695041, cmdFLog2)
0943     00            ; Frame_Call_Return
0944     64            ; Push_LocalMem_Long_1
0945     3B 3FB8AA3B   ; Push_Long_Lit, $3FB8AA3B
094A     C4 88 44      ; Push_ObjectMem_Long, $0844
094D     05 29         ; Call, $29
094F     33            ; Pop_Return
0950     32            ; Return
0951                   PUB Log2(a)
0951                       return SetCommand(a, 0, cmdFLog2)
0951     00            ; Frame_Call_Return
0952     64            ; Push_LocalMem_Long_1
0953     35            ; Push_0
0954     C4 88 44      ; Push_ObjectMem_Long, $0844
0957     05 29         ; Call, $29
0959     33            ; Pop_Return
095A     32            ; Return
095B                   PUB Log10(a)
095B                       return SetCommand(a, 3.321928095, cmdFLog2)
095B     00            ; Frame_Call_Return
095C     64            ; Push_LocalMem_Long_1
095D     3B 40549A78   ; Push_Long_Lit, $40549A78
0962     C4 88 44      ; Push_ObjectMem_Long, $0844
0965     05 29         ; Call, $29
0967     33            ; Pop_Return
0968     32            ; Return
0969                   PUB Exp(a)
0969                       return SetCommand(a, 1.442695041, cmdFExp2)
0969     00            ; Frame_Call_Return
096A     64            ; Push_LocalMem_Long_1
096B     3B 3FB8AA3B   ; Push_Long_Lit, $3FB8AA3B
0970     C4 88 48      ; Push_ObjectMem_Long, $0848
0973     05 29         ; Call, $29
0975     33            ; Pop_Return
0976     32            ; Return
0977                   PUB Exp2(a)
0977                       return SetCommand(a, 0, cmdFExp2)
0977     00            ; Frame_Call_Return
0978     64            ; Push_LocalMem_Long_1
0979     35            ; Push_0
097A     C4 88 48      ; Push_ObjectMem_Long, $0848
097D     05 29         ; Call, $29
097F     33            ; Pop_Return
0980     32            ; Return
0981                   PUB Exp10(a)
0981                       return SetCommand(a, 3.321928095, cmdFExp2)
0981     00            ; Frame_Call_Return
0982     64            ; Push_LocalMem_Long_1
0983     3B 40549A78   ; Push_Long_Lit, $40549A78
0988     C4 88 48      ; Push_ObjectMem_Long, $0848
098B     05 29         ; Call, $29
098D     33            ; Pop_Return
098E     32            ; Return
098F                   PUB Pow(a, b)
098F                       return SetCommand(a, b, cmdFPow)
098F     00            ; Frame_Call_Return
0990     64            ; Push_LocalMem_Long_1
0991     68            ; Push_LocalMem_Long_2
0992     C4 88 4C      ; Push_ObjectMem_Long, $084C
0995     05 29         ; Call, $29
0997     33            ; Pop_Return
0998     32            ; Return
0999                   PUB Frac(a)
0999                       return SetCommand(a, 0, cmdFFrac)
0999     00            ; Frame_Call_Return
099A     64            ; Push_LocalMem_Long_1
099B     35            ; Push_0
099C     C4 88 50      ; Push_ObjectMem_Long, $0850
099F     05 29         ; Call, $29
09A1     33            ; Pop_Return
09A2     32            ; Return
09A3                   PUB Rad(a)
09A3                       return SetCommand(a, constant(pi / 180.0), cmdFMul)
09A3     00            ; Frame_Call_Return
09A4     64            ; Push_LocalMem_Long_1
09A5     3B 3C8EFA35   ; Push_Long_Lit, $3C8EFA35
09AA     C4 88 1C      ; Push_ObjectMem_Long, $081C
09AD     05 29         ; Call, $29
09AF     33            ; Pop_Return
09B0     32            ; Return
09B1                   PUB Deg(a)
09B1                       return SetCommand(a, constant(180.0 / pi), cmdFMul)
09B1     00            ; Frame_Call_Return
09B2     64            ; Push_LocalMem_Long_1
09B3     3B 42652EE0   ; Push_Long_Lit, $42652EE0
09B8     C4 88 1C      ; Push_ObjectMem_Long, $081C
09BB     05 29         ; Call, $29
09BD     33            ; Pop_Return
09BE     32            ; Return
09BF                   PUB ArcSin(a)
09BF                       return SetCommand(a, 1, cmdASinCos)
09BF     00            ; Frame_Call_Return
09C0     64            ; Push_LocalMem_Long_1
09C1     36            ; Push_1
09C2     C4 88 58      ; Push_ObjectMem_Long, $0858
09C5     05 29         ; Call, $29
09C7     33            ; Pop_Return
09C8     32            ; Return
09C9                   PUB ArcCos(a)
09C9                       return SetCommand(a, 0, cmdASinCos)
09C9     00            ; Frame_Call_Return
09CA     64            ; Push_LocalMem_Long_1
09CB     35            ; Push_0
09CC     C4 88 58      ; Push_ObjectMem_Long, $0858
09CF     05 29         ; Call, $29
09D1     33            ; Pop_Return
09D2     32            ; Return
09D3                   PUB ArcTan(a)
09D3                       return SetCommand(a, 1.0, cmdATan2)
09D3     00            ; Frame_Call_Return
09D4     64            ; Push_LocalMem_Long_1
09D5     3B 3F800000   ; Push_Long_Lit, $3F800000
09DA     C4 88 5C      ; Push_ObjectMem_Long, $085C
09DD     05 29         ; Call, $29
09DF     33            ; Pop_Return
09E0     32            ; Return
09E1                   PUB ArcTan2(a, b)
09E1                       return SetCommand(a, b, cmdATan2)
09E1     00            ; Frame_Call_Return
09E2     64            ; Push_LocalMem_Long_1
09E3     68            ; Push_LocalMem_Long_2
09E4     C4 88 5C      ; Push_ObjectMem_Long, $085C
09E7     05 29         ; Call, $29
09E9     33            ; Pop_Return
09EA     32            ; Return
09EB                   PUB Floor(a)
09EB                       return SetCommand(a, 0, cmdFloor)
09EB     00            ; Frame_Call_Return
09EC     64            ; Push_LocalMem_Long_1
09ED     35            ; Push_0
09EE     C4 88 64      ; Push_ObjectMem_Long, $0864
09F1     05 29         ; Call, $29
09F3     33            ; Pop_Return
09F4     32            ; Return
09F5                   PUB Ceil(a)
09F5                       return SetCommand(a, 0, cmdCeil)
09F5     00            ; Frame_Call_Return
09F6     64            ; Push_LocalMem_Long_1
09F7     35            ; Push_0
09F8     C4 88 60      ; Push_ObjectMem_Long, $0860
09FB     05 29         ; Call, $29
09FD     33            ; Pop_Return
09FE     32            ; Return
09FF                   PUB Minimum(a, b)
09FF                       result := SetCommand(a, b, cmdFCmp)
09FF     00            ; Frame_Call_Return
0A00     64            ; Push_LocalMem_Long_1
0A01     68            ; Push_LocalMem_Long_2
0A02     C4 88 34      ; Push_ObjectMem_Long, $0834
0A05     05 29         ; Call, $29
0A07     61            ; Pop_LocalMem_Long_0
0A08                       if result < 0
0A08     60            ; Push_LocalMem_Long_0
0A09     35            ; Push_0
0A0A     F9            ; Less
0A0B     0A 02         ; Jump_If_False, $0002
0A0D                         return a
0A0D     64            ; Push_LocalMem_Long_1
0A0E     33            ; Pop_Return
0A0F                       return b
0A0F     68            ; Push_LocalMem_Long_2
0A10     33            ; Pop_Return
0A11     32            ; Return
0A12                   PUB Maximum(a, b)
0A12                       result := SetCommand(a, b, cmdFCmp)
0A12     00            ; Frame_Call_Return
0A13     64            ; Push_LocalMem_Long_1
0A14     68            ; Push_LocalMem_Long_2
0A15     C4 88 34      ; Push_ObjectMem_Long, $0834
0A18     05 29         ; Call, $29
0A1A     61            ; Pop_LocalMem_Long_0
0A1B                       if result < 0
0A1B     60            ; Push_LocalMem_Long_0
0A1C     35            ; Push_0
0A1D     F9            ; Less
0A1E     0A 02         ; Jump_If_False, $0002
0A20                         return b
0A20     68            ; Push_LocalMem_Long_2
0A21     33            ; Pop_Return
0A22                       return a
0A22     64            ; Push_LocalMem_Long_1
0A23     33            ; Pop_Return
0A24     32            ; Return
0A25                   PUB Cmd_ptr
0A25                       return @f32_Cmd
0A25     43            ; Reference_VariableMem_Long_0
0A26     33            ; Pop_Return
0A27     32            ; Return
0A28                   PUB Call_ptr
0A28                       return @cmdCallTable
0A28     C7 88 14      ; Reference_ObjectMem_Long, $0814
0A2B     33            ; Pop_Return
0A2C     32            ; Return
0A2D                   PRI SetCommand(a, b, cmd)
0A2D                       result  := cmd
0A2D     6C            ; Push_LocalMem_Long_3
0A2E     61            ; Pop_LocalMem_Long_0
0A2F                       f32_Cmd := @result
0A2F     63            ; Reference_LocalMem_Long_0
0A30     41            ; Pop_VariableMem_Long_0
0A31                       repeat
0A31     40            ; Push_VariableMem_Long_0
0A32     0B 7D         ; Jump_If_True, $FFFD
0A34     32            ; Return
0A35     00            ; Frame_Call_Return
0A36     00            ; Frame_Call_Return
0A37     00            ; Frame_Call_Return
                       Variables for TOP (math.float.spin)
0A38     0000          long F32_CMD
0A3C     0004          byte COG
0A40                   Reserved 8 bytes.
0A48                   Base of stack.
0A58                   Top of stack.

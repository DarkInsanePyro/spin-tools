'' =================================================================================================
''
''   File....... jm_tm1638.spin2
''   Purpose.... TM1638 driver and display routines
''   Author..... Jon "JonnyMac" McPhalen
''               Copyright (c) 2019-2020 Jon McPhalen
''               -- see below for terms of use
''   E-mail..... jon@jonmcphalen.com
''   Started....
''   Updated.... 06 SEP 2020
''
'' =================================================================================================


con { fixed io pins }

  RX1      = 63  { I }                                          ' programming / debug
  TX1      = 62  { O }

  SF_CS    = 61  { O }                                          ' serial flash
  SF_SCK   = 60  { O }
  SF_SDO   = 59  { O }
  SF_SDI   = 58  { I }


con { tm1638 }

  WR_DATA = $40                                                 ' write data (auto increment)
  RD_BTNS = $42                                                 ' read buttons
  WR_FIXD = $44                                                 ' fixed address

  DSP_OFF = $80                                                 ' display off
  DSP_ON  = $88                                                 ' display on

  WR_SEGS = $C0                                                 ' segments address base
  WR_LEDS = $C1                                                 ' leds address base


obj

  fmt  : "jm_nstr"                                              ' numeric formatting routines
  smap : "jm_tm163x_segs7"                                      ' 7-segment maps


var

  byte  size                                                    ' size of display (columns)

  long  stb                                                     ' stb (cs) pin
  long  clk                                                     ' clock pin
  long  dio                                                     ' data io

  long  tix                                                     ' clock tix in 1/4 period

  word  buffer[8]                                               ' state of segments/leds


pub null()

'' This is not a top-level object


pub start(ncols, stbpin, clkpin, diopin, hz)

'' Configure IO and intialize display
'' -- ncols is the number of columsn used (1..8)
'' -- stbpin is chip enable/stand-by
'' -- clkpin is clock pin
'' -- diopin is for data to/from TMS1638
'' -- hz is clock frequency (1..1_000_000)

  size := 1 #> ncols <# 8                                       ' set display size

  stb := stbpin                                                 ' save pin
  pinclear(stb)                                                 ' clear smart pin mode
  pinhigh(stb)                                                  ' deselect device

  clk := clkpin
  pinclear(clk)
  pinhigh(clk)                                                  ' idle state is high

  dio := diopin
  pinclear(dio)
  wrpin(dio, P_HIGH_FLOAT)                                      ' dio is open-drain

  tix := (clkfreq / hz) >> 2                                    ' ticks in 1/4 period

  display_off()                                                 ' let app enable dsiplay
  clear()                                                       ' segs and leds off


pub clear()

'' Clears segments and discrete LEDs

  fill($00, $00)                                                ' clear segs and leds


pub fill(segs, leds)

'' Fill display segments and LEDs
'' -- segs are the 7-segment bits, %00000000 to %11111111
'' -- leds are discrete LEDs, 0 (off), 1 (on), 2 (on), >2 (off)
''    * some displays use RG LED

  send_command(WR_DATA)                                         ' auto increment

  segs.byte[1] := %00 #> leds <# %11                            ' convert bytes to a word

  wordfill(@buffer, segs, 8)                                    ' update buffer

  pinlow(stb)                                                   ' select
  write(WR_SEGS)                                                ' set starting register
  repeat 8                                                      ' fill 8 7-segs & 8 leds
    write(segs)                                                 '  segs are at $C0, C2, C4 ...
    write(leds)                                                 '  leds are at $C1, C3, C5 ...
  pinhigh(stb)                                                  ' deselect


pub display_on(level)

'' Display on at brightness level
'' -- level is 0..7

  if (level < 0)
    send_command(DSP_OFF)
  else
    send_command(DSP_ON | (0 #> level <# 7))


pub display_off()

'' Turns off display elements (segs & leds)
'' -- does not modify display registers
'' -- can be used to flash display

  send_command(DSP_OFF)


pub set_segments(col, segs)

'' Write bits into segments register at col
'' -- col is 0..7 (left to right)
'' -- segs are the segment bits a..g, dp

  if ((col < 0) or (col > 7))                                   ' validate column
    return

  buffer.byte[col << 1] := segs                                 ' segments are on even boundaries

  pinlow(stb)
  write(WR_SEGS + (col << 1))                                   ' point to segs regiter
  write(segs)                                                   ' send it to the display
  pinhigh(stb)


pub set_digit(col, value, dp) | bits

'' Write hex digit at column with optional decimal point
'' -- col is 0..size-1
'' -- value is 0..15
'' -- dp is 0 (false) or 1 (true)

  if ((col < 0) or (col > size))
    return

  if ((value < 0) or (value > 15))                              ' bin, quad, octal, dec, or hex digit
    return

  if (dp)                                                       ' clean-up dp
    dp := smap.SEG_DP

  set_segments(col, smap.digit(value, 16) | dp)                 ' update column


pub set_char(col, ch, dp) | bits, offset

'' Write ASCII character (if possible) to specified digit of display at addr
'' -- col is 0..size-1
'' -- ch is ASCII char, 32..127
'' -- dp is 0 (false) or 1 (true)

  if ((col < 0) or (col > size))
    return

  ch := smap.ascii(ch)

  if (dp)
    ch |= smap.SEG_DP

  set_segments(col, ch)


pub set_dpoint(col, state) | segs

'' Set or clear decimal point on digit in display at addr
'' -- addr is the address of the display (0..7)

  if ((col < 0) or (col > 7))
    return

  segs := buffer.byte[col<<1]

  if (state)
    ifnot (segs & smap.SEG_DP)
      set_segments(col, segs | smap.SEG_DP)                     ' dp on
  else
    if (segs & smap.SEG_DP)
      set_segments(col, segs & !smap.SEG_DP)                    ' dp off


pub str(col, p_str, len) | ch, la, segs, p_buf

'' Write string to display
'' -- col is starting column (0..size-1)
'' -- p_str is pointer to string
'' -- len is # of characters to print (0 for auto-size)
''    * decimal points do not count in length
''    * e.g., "1.2.3.4.5.6." is considered len = 6

  if ((col < 0) or (col >= size))
    return

  if (len <= 0)
    len := strsize(p_str)                                       ' auto size

  send_command(WR_DATA)                                         ' auto increment characters

  p_buf := @buffer + (col << 1)                                 ' point to buffer

  pinlow(stb)                                                   ' prep to write segs/leds
  write(WR_SEGS | (col << 1))                                   ' initial column
  repeat while (len)
    ch := byte[p_str++]                                         ' get a character
    if (ch == 0)                                                ' if at end
      quit                                                      '  we're done
    else                                                        ' else
      segs := smap.ascii(ch)                                    '  convert to segments
      if (ch <> ".")                                            '  if not leading .
        la := byte[p_str]                                       '   look ahead to next character
        if (la == ".")                                          '   if .
          segs |= smap.SEG_DP                                   '    add to segments
          ++p_str                                               '    move past .
      byte[p_buf++] := segs                                     '  save to buffer
      write(segs)                                               '  write segments
      write(byte[p_buf++])                                      '  refresh leds
      if (++col == size)                                        '  update column
        quit
      len -= 1                                                  '  update length
  pinhigh(stb)                                                  ' deselect


pub dec(col, value)

'' Write left-justified decimal value
'' -- col is starting column

  str(col, fmt.dec(value, 0), -1)


pub rjdec(col, value, width, pchar) | p_str

'' Write right-justified decimal  value
'' -- col is starting column
'' -- programmer is responsible with col/width values

  str(col, fmt.fmt_number(value, "d", 0, width, pchar), width)


pub fpdec(col, value, width, dp) | p_str, idx

'' Write fixed-point decimal value
'' -- col is starting column
'' -- value will be written
'' -- width is characters to print
'' -- dp is number of digits after decimal point (1 to 7)

  if ((dp < 1) or (dp > 7) or (dp >= width))                    ' ignore dp if bad
    rjdec(col, value, width, " ")
  else
    p_str := fmt.fmt_number(value, "d", 0, width, " ")          ' convert to rj string
    dp := width-1 - dp                                          ' find dp position in string
    repeat idx from dp to width-1                               ' fix 0s around/after dp if needed
      if (byte[p_str][idx ] == " ")
        byte[p_str][idx ] := "0"
      else
        quit
    str(col, p_str, width)                                      ' write numeric string
    set_dpoint(dp+col, 1)                                       ' set decimal point


pub hex(col, value) | p_str, idx

'' Write variable-width hex  value
'' -- col is starting column

  p_str := fmt.itoa(value, 16, 0)                               ' convert to hex string

  hex_fix(p_str)                                                ' fix problem chars

  str(col, p_str, -1)                                           ' print


pub fhex(col, value, width) | p_str

'' Write fixed-width hex value
'' -- col is starting column
'' -- width is number of digits to write
''    * uses leading 0s as pad

  p_str := fmt.itoa(value, 16, width)                           ' convert to fixed hex string

  hex_fix(p_str)

  str(col, p_str, -1)


pri hex_fix(p_str) | idx, c

  repeat idx from 0 to strsize(p_str)-1                         ' loop through string
    c := byte[p_str][idx]                                       ' grab a character
    if ((c == "B") or (c == "D"))                               ' problem for 7-seg display?
      byte[p_str][idx] += 32                                    '  covert to lowercase


pub bin(col, value)

'' Write variable-width binary value
'' -- col is starting column

  str(col, fmt.itoa(value, 2, 0) , -1)


pub fbin(col, value, width)

'' Write fixed-width binary value
'' -- col is starting column
'' -- width is number of digits to write
''    * uses leading 0s as pad

  str(col, fmt.itoa(value, 2, width), width)


pub set_led(col, state)

'' Write state of discrete led
'' -- col is 0..7
'' -- state is 0 (off), 1 (on), 2 (on)
''    * some displays use RG LED, hence have two on states

  if ((col < 0) or (col >= size))
    return

  if ((state < 0) or (state > 2))
    return

  if (buffer.byte[(col<<1)+1] <> state)                         ' if new state
    buffer.byte[(col<<1)+1] := state                            ' save new state to buffer
    send_command(WR_FIXD)                                       ' disable auto-incrment
    pinlow(stb)
    write(WR_LEDS+(col<<1))                                     ' select led
    write(state)                                                ' write state
    pinhigh(stb)


pub write_leds(ctrl, state) | col, idx

'' Write state to leds
'' -- ctrl is control byte
''    * 1 in ctrl enables state
''    * 0 in ctrl leaves led as is
'' -- best for several simultaneous changes

  if (state < 0) or (state > 2)
    return

  send_command(WR_DATA)                                         ' auto-incrment

  pinlow(stb)
  write(WR_SEGS)                                                ' start of TM1638 segs memory

  repeat idx from 0 to 15
    ifnot (idx & 1)                                             ' if even address
      write(buffer.byte[idx])                                   '  refresh segments
    else
      if (ctrl & (1 << (idx>>1)))                               '  is this column selected?
        buffer.byte[idx] := state                               '   yes set new state
      write(buffer.byte[idx])                                   '  update led at this column
  pinhigh(stb)


pub paint_leds(colors) | idx, segs

'' Paint discrete LEDs with colors
'' -- colors is quarternary word that describes LED color

  send_command(WR_DATA)                                         ' auto-incrment

  pinlow(stb)
  write(WR_SEGS)                                                ' point to start of TM1638 segs memory
  repeat idx from 0 to 15
    ifnot (idx & 1)                                             ' if even address
      write(buffer.byte[idx])                                   '  refresh segments
    else                                                        ' else
      buffer.byte[idx] := colors & %11                          '  update led color
      write(buffer.byte[idx])                                   '  write to display
      colors >>= 2
  pinhigh(stb)


pub read_buttons() : result | idx

'' Returns state of buttons
'' -- active high

  pinlow(stb)
  write(RD_BTNS)
  pinf(dio)
  waitus(2)
  repeat idx from 0 to 3
    result |= read() << idx
  pinhigh(stb)


con { data transfer }

pri send_command(cmd)

  pinlow(stb)
  write(cmd)
  pinhigh(stb)


pri write(b) | c, d, t

'' Write byte b to TM1638
'' -- LSBPRE

  longmove(@c, @clk, 3)                                         ' copy pins and timing

  org
                rep       #8, #8                                ' 8 bits
                 shr      b, #1                         wc      ' get lsb
                 drvc     d                                     ' write to data pin
                 waitx    t                                     ' let d settle
                 drvl     c                                     ' clock the bit
                 waitx    t
                 waitx    t
                 drvh     c
                 waitx    t
  end


pri read() : b  | c, d, t

'' Read byte b from TM1638
'' -- LSBPOST

  longmove(@c, @clk, 3)                                         ' copy pins and timing

  org
                flth      d                                     ' float dio to pull-up

                rep       #8, #8                                ' 8 bits
                 waitx    t                                     ' clock the bit
                 drvl     c
                 waitx    t
                 waitx    t
                 drvh     c
                 waitx    t
                 testp    d                             wc      ' get lsb
                 rcr      b, #1                                 ' move into b

                shr       b, #24                                ' align lsb to bit 0
  end


con { license }

{{

  MIT License

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.

}}